{"pages":[{"title":"文章分类","text":"","link":"/categories/index.html"}],"posts":[{"title":"我的第一篇博客文章","text":"这是我的第一篇博客，好激动啊，我要笑一会！！ 哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈 参考文献www.codesheep.cnb站视频","link":"/2020/12/13/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"},{"title":"用Markdown编写博客指南","text":"1.关于博客日常改动，2.Markdown语法使用指南 关于博客日常改动在本地对博客进行修改（添加新博文、修改样式等等）后，通过Git进行管理 ​ 1.依次执行以下三条命令，同步到Github中 123git cgit ggit d Markdown语法使用指南（typora）代码块：123#在英文输入下，输入三个```+语言 ​```python​```java 1.python代码 1print(&quot;hello world!&quot;) 标题：123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 字体123**加粗**~~删除线~~*斜体* 加粗删除线斜体 引用12#引用语法&gt;作者 作者 分割线123//分割线---*** 图片插入12#在线图片，本地图片！[图片](图片地址或者url) 超链接12//超链接[我的网站](https://github.com/xuhaha456) 我的网站 列表123456#无序列表-目录1-目录2-目录3#有序列表1+.+名称 目录1 目录2 目录3 表格1#直接用软件插入，手写代码太麻烦 语文 数学 100 100 段落首行缩进最近发现，通过Markdown写的文章首行没有缩进2格，即使在Typora中显示有缩进（自己多敲了几个空格），网上查了下资料，这种原因是Markdown对中文的支持不全导致的。 解决方法：直接手动添加空格符号(每个表示一个空格，连续使用两个即可，注意后面的分号不要掉了） 123&amp;ensp;或&amp;#8194; //半角的空格&amp;emsp;或&amp;#8195; //全角的空格（中文的话，一般就直接用两个&amp;emsp;即可）&amp;nbsp;或&amp;#160; //不断行的空格 例如： 1&amp;emsp;&amp;emsp;段落内容 //效果便是[空格][空格]段落内容","link":"/2020/12/14/%E7%94%A8Markdown%E7%BC%96%E5%86%99%E5%8D%9A%E5%AE%A2%E6%8C%87%E5%8D%97/"},{"title":"莫烦老师GA算法学习笔记","text":"如果让我用一句话概括遗传算法: 在程序里生宝宝, 杀死不乖的宝宝, 让乖宝宝继续生宝宝. 遗传算法下面为莫烦老师遗传算法源代码 中文注释均为徐哈哈同学在学习过程中，为了自身的学习，添加的笔记 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123import numpy as npimport matplotlib.pyplot as plt# ------------- 参数控制面板-----------DNA_SIZE = 10 # DNA lengthPOP_SIZE = 100 # population sizeCROSS_RATE = 0.8 # mating probability (DNA crossover)MUTATION_RATE = 0.003 # mutation probabilityN_GENERATIONS = 100X_BOUND = [0, 5] # x upper and lower bounds# --------函数集合----------def F(x): return np.sin(10 * x) * x + np.cos(2 * x) * x # to find the maximum of this function# find non-zero fitness for selectiondef get_fitness(pred): return pred + 1e-3 - np.min(pred)# 因为如果直接返回pred可能是负值，而我们在计算概率的时候不能为负值。# 要进行处理，np.min表示取最小，为最大的负数，可以使全部只变成正的；1e-3为了让float进行相除防止小数点后的数被省略# convert binary DNA to decimal and normalize it to a range(0, 5)# 对基因的翻译，如这里函数，x轴是实数，这里解释了如何将遗传0、1序列翻译成实数。用十进制二进制转换# pop (population)是一个储存二进制 DNA 的矩阵, 他的 shape 是这样 (pop_size, DNA_size)# 这里DNA_SIZE，X_BOUND是超参数def translateDNA(pop): return pop.dot(2 ** np.arange(DNA_SIZE)[::-1]) / float(2 ** DNA_SIZE - 1) * X_BOUND[1]def select(pop, fitness): # nature selection wrt pop's fitness idx = np.random.choice(np.arange(POP_SIZE), size=POP_SIZE, replace=True, p=fitness / fitness.sum()) # numpy.random.choice(a, size=None, replace=True, p=None) # 从a(只要是nparray都可以，但必须是一维的)中随机抽取数字，并组成指定大小(size)的数组 # replace:True表示可以取相同数字，False表示不可以取相同数字 # 数组p：与数组a相对应，表示取数组a中每个元素的概率，默认为选取每个元素的概率相同。 # 这里概率不能为负，所以pred要进行非负处理 # replace表示抽样后是否放回，这里为True表示有放回，则可能会出现相同的索引值 # p 就是选它的比例，按比例来选择适应度高的,也会保留一些适应度低的，因为也可能后面产生更好的变异 # np.random.choice表示从序列中取值 np.arange()函数返回一个有终点和起点的固定步长的排列 return pop[idx]def crossover(parent, pop): # mating process (genes crossover) if np.random.rand() &lt; CROSS_RATE: i_ = np.random.randint(0, POP_SIZE, size=1) # select another individual from pop cross_points = np.random.randint(0, 2, size=DNA_SIZE).astype(np.bool) # choose crossover points parent[cross_points] = pop[i_, cross_points] # mating and produce one child return parentdef mutate(child): for point in range(DNA_SIZE): if np.random.rand() &lt; MUTATION_RATE: child[point] = 1 if child[point] == 0 else 0 return child# --------------------主程序开始--------------------------------pop = np.random.randint(2, size=(POP_SIZE, DNA_SIZE)) # initialize the pop DNA# np.ransom.randint函数是随机生成[0，2）之间，长度为DNA_SIZE的向量POP_SIZE个# size=（a，b，c）c为一维向量数量，b为二维向量的数量，a为三维向量的数量# 例[[1010101010]# [1011101001]# ...]plt.ion() # something about plotting# 在使用matplotlib的过程中，不能像matlab一样同时开几个窗口进行比较，可以采用交互模式，但是放在脚本里运行一闪而过，图像并不停留# python可视化库matplotlib有两种显示模式：阻塞（block）模式&amp;交互（interactive）模式# 在交互模式下：plt.plot(x)或plt.imshow(x)是直接出图像，不需要plt.show()# 如果在脚本中使用ion()命令开启了交互模式，没有使用ioff()关闭的话，则图像不会常留。防止这种情况，需要在plt.show()之前加上ioff()命令。# 在阻塞模式下：打开一个窗口以后必须关掉才能打开下一个新的窗口。这种情况下，默认是不能像Matlab一样同时开很多窗口进行对比的# plt.plot(x)或plt.imshow(x)是直接出图像，需要plt.show()后才能显示图像x = np.linspace(*X_BOUND, 200)# np.linspace()函数是在a，b范围，平均取c个数，作为矩阵x的元素（a，b，c）# X_BOUND = [0, 5],要产生200个样本点plt.plot(x, F(x))# 在交互模式下：plt.plot(x)或plt.imshow(x)是直接出图像，不需要plt.show()for _ in range(N_GENERATIONS): # for _ in range(N_GENERATIONS):中_为临时变量 # 效果和for i in range(N_GENERATIONS):一样 F_values = F(translateDNA(pop)) # compute function value by extracting DNA # something about plotting if 'sca' in globals(): sca.remove() sca = plt.scatter(translateDNA(pop), F_values, s=200, lw=0, c='red', alpha=0.5); # scatter函数就是在函数图像上画出当前种群每个个体对应的（x，y）的位置 # 参数列表（x，y，s为散点面积，lw未知，c为颜色，alpha为透明度） plt.pause(0.05) # 控制图像停留时间 # GA part (evolution) fitness = get_fitness(F_values) print(&quot;Most fitted DNA: &quot;, pop[np.argmax(fitness), :]) pop = select(pop, fitness) pop_copy = pop.copy() for parent in pop: child = crossover(parent, pop_copy) child = mutate(child) parent[:] = child # parent is replaced by its childplt.ioff()plt.show()# 展示最后一代的个体所在图像位置# 数字作为变量在程序中称为幻数，尽量减少程序中以幻数作为变量的出现# 总体算法过程# 初始化种群-&gt;绘制函数曲线-&gt;开始进入for循环# for循环里# 计算每一点函数值-&gt;把每一点打印在图上-&gt;计算适应度-&gt;根据适应度选择-&gt;交叉变异# 数据结构过程# 初始种群pop-&gt;计算每一个体的y值-&gt;通过y值计算每一个体的适应度-&gt;对个体进行选择-&gt;繁衍交叉变异# 此算法缺陷1：种群个体x值在translateDNA时，默认全部翻译为正数。若函数最大值在二三象限，此算法无法找出最优解，即使修改# x的界限，也无济于事。# 解决办法1：在translateDNA函数中引入（0，1）符号位定义，并加入if判断，判断条件为符号位数值为1，且x界限最小值为负数，# 若条件为真，就将其翻译为负值，否则，翻译结果保持不变。 对遗传算法缺陷1做出改进以下为哈哈同学对遗传算法缺陷1提供的解决方案 123456789101112131415161718192021222324252627&quot;&quot;&quot;此算法已完全实现缺陷1的解决方案，经过多轮测试，无明显且常见错误出现此算法在原有GA算法的基础上，只对plt.pause()函数和translateDNA函数进行修改，translateDNA函数相关修改说明写于translateDNA函数附近，plt.pause()函数将时间参数从0.05调整为0.001.&quot;&quot;&quot;def translateDNA(pop): pop_l = pop.dot(2 ** np.arange(DNA_SIZE)[::-1]) / float(2 ** DNA_SIZE - 1) * (X_BOUND[1] - X_BOUND[0]) if X_BOUND[0] &lt; 0: for i in range(POP_SIZE): if pop[i, 0] == 1: pop_l[i] = (-1) * (pop_l[i] - 512 / float(2 ** DNA_SIZE - 1) * (X_BOUND[1] - X_BOUND[0])) return pop_l&quot;&quot;&quot;在原有算法的基础上，此算法将基因的首位二进制数作为符号位，其中0代表正数，1代表负数。第一行：创建临时矩阵pop_l，临时用于保存pop进行二—十进制翻译后数值结果第二行提前判断x的取值，目的是为了当函数定义域在x轴正半轴时，跳过循环，加快算法运算速度第三行到第五行代码将遍历整个pop矩阵，对每一个基因向量的符号位做出判断如果某一基因向量的符号位为一，则对表现型矩阵pop_l中相应数值取负值，因为符号位也参与到了二—十进制的翻译所以通过pop_l[i] - 512 / float(2 ** DNA_SIZE - 1) * (X_BOUND[1] - X_BOUND[0])减去负数符号位对数值的影响因为正数符号位为0，所以不用考虑正数对最终数值的影响。&quot;&quot;&quot;plt.pause(0.001) # 将时间参数从0.05修改为0.001 例子 配对句子以下为莫烦老师的源代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import numpy as npTARGET_PHRASE = 'You get it!' # target DNAPOP_SIZE = 300 # population sizeCROSS_RATE = 0.4 # mating probability (DNA crossover)MUTATION_RATE = 0.01 # mutation probabilityN_GENERATIONS = 1000DNA_SIZE = len(TARGET_PHRASE)TARGET_ASCII = np.fromstring(TARGET_PHRASE, dtype=np.uint8) # convert string to numberASCII_BOUND = [32, 126]class GA(object): def __init__(self, DNA_size, DNA_bound, cross_rate, mutation_rate, pop_size): self.DNA_size = DNA_size DNA_bound[1] += 1 self.DNA_bound = DNA_bound self.cross_rate = cross_rate self.mutate_rate = mutation_rate self.pop_size = pop_size self.pop = np.random.randint(*DNA_bound, size=(pop_size, DNA_size)).astype(np.int8) # int8 for convert to ASCII def translateDNA(self, DNA): # convert to readable string return DNA.tostring().decode('ascii') def get_fitness(self): # count how many character matches match_count = (self.pop == TARGET_ASCII).sum(axis=1) return match_count def select(self): fitness = self.get_fitness() + 1e-4 # add a small amount to avoid all zero fitness idx = np.random.choice(np.arange(self.pop_size), size=self.pop_size, replace=True, p=fitness/fitness.sum()) return self.pop[idx] def crossover(self, parent, pop): if np.random.rand() &lt; self.cross_rate: i_ = np.random.randint(0, self.pop_size, size=1) # select another individual from pop cross_points = np.random.randint(0, 2, self.DNA_size).astype(np.bool) # choose crossover points parent[cross_points] = pop[i_, cross_points] # mating and produce one child return parent def mutate(self, child): for point in range(self.DNA_size): if np.random.rand() &lt; self.mutate_rate: child[point] = np.random.randint(*self.DNA_bound) # choose a random ASCII index return child def evolve(self): pop = self.select() pop_copy = pop.copy() for parent in pop: # for every parent child = self.crossover(parent, pop_copy) child = self.mutate(child) parent[:] = child self.pop = popif __name__ == '__main__': ga = GA(DNA_size=DNA_SIZE, DNA_bound=ASCII_BOUND, cross_rate=CROSS_RATE, mutation_rate=MUTATION_RATE, pop_size=POP_SIZE) for generation in range(N_GENERATIONS): fitness = ga.get_fitness() best_DNA = ga.pop[np.argmax(fitness)] best_phrase = ga.translateDNA(best_DNA) print('Gen', generation, ': ', best_phrase) if best_phrase == TARGET_PHRASE: break ga.evolve() 例子 旅行商问题(TSP)以下为莫烦老师的源代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495import matplotlib.pyplot as pltimport numpy as npN_CITIES = 20 # DNA sizeCROSS_RATE = 0.1MUTATE_RATE = 0.02POP_SIZE = 500N_GENERATIONS = 5000class GA(object): def __init__(self, DNA_size, cross_rate, mutation_rate, pop_size, ): self.DNA_size = DNA_size self.cross_rate = cross_rate self.mutate_rate = mutation_rate self.pop_size = pop_size self.pop = np.vstack([np.random.permutation(DNA_size) for _ in range(pop_size)]) def translateDNA(self, DNA, city_position): # get cities' coord in order line_x = np.empty_like(DNA, dtype=np.float64) line_y = np.empty_like(DNA, dtype=np.float64) for i, d in enumerate(DNA): city_coord = city_position[d] line_x[i, :] = city_coord[:, 0] line_y[i, :] = city_coord[:, 1] return line_x, line_y def get_fitness(self, line_x, line_y): total_distance = np.empty((line_x.shape[0],), dtype=np.float64) for i, (xs, ys) in enumerate(zip(line_x, line_y)): total_distance[i] = np.sum(np.sqrt(np.square(np.diff(xs)) + np.square(np.diff(ys)))) fitness = np.exp(self.DNA_size * 2 / total_distance) return fitness, total_distance def select(self, fitness): idx = np.random.choice(np.arange(self.pop_size), size=self.pop_size, replace=True, p=fitness / fitness.sum()) return self.pop[idx] def crossover(self, parent, pop): if np.random.rand() &lt; self.cross_rate: i_ = np.random.randint(0, self.pop_size, size=1) # select another individual from pop cross_points = np.random.randint(0, 2, self.DNA_size).astype(np.bool) # choose crossover points keep_city = parent[~cross_points] # find the city number swap_city = pop[i_, np.isin(pop[i_].ravel(), keep_city, invert=True)] parent[:] = np.concatenate((keep_city, swap_city)) return parent def mutate(self, child): for point in range(self.DNA_size): if np.random.rand() &lt; self.mutate_rate: swap_point = np.random.randint(0, self.DNA_size) swapA, swapB = child[point], child[swap_point] child[point], child[swap_point] = swapB, swapA return child def evolve(self, fitness): pop = self.select(fitness) pop_copy = pop.copy() for parent in pop: # for every parent child = self.crossover(parent, pop_copy) child = self.mutate(child) parent[:] = child self.pop = popclass TravelSalesPerson(object): def __init__(self, n_cities): self.city_position = np.random.rand(n_cities, 2) plt.ion() def plotting(self, lx, ly, total_d): plt.cla() plt.scatter(self.city_position[:, 0].T, self.city_position[:, 1].T, s=100, c='k') plt.plot(lx.T, ly.T, 'r-') plt.text(-0.05, -0.05, &quot;Total distance=%.2f&quot; % total_d, fontdict={'size': 20, 'color': 'red'}) plt.xlim((-0.1, 1.1)) plt.ylim((-0.1, 1.1)) plt.pause(0.01)ga = GA(DNA_size=N_CITIES, cross_rate=CROSS_RATE, mutation_rate=MUTATE_RATE, pop_size=POP_SIZE)env = TravelSalesPerson(N_CITIES)for generation in range(N_GENERATIONS): lx, ly = ga.translateDNA(ga.pop, env.city_position) fitness, total_distance = ga.get_fitness(lx, ly) ga.evolve(fitness) best_idx = np.argmax(fitness) print('Gen:', generation, '| best fit: %.2f' % fitness[best_idx],) env.plotting(lx[best_idx], ly[best_idx], total_distance[best_idx])plt.ioff()plt.show()","link":"/2020/12/15/%E8%8E%AB%E7%83%A6%E8%80%81%E5%B8%88GA%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"Git学习与使用指南","text":"大名鼎鼎的Git软件，长期以来获得计算机从业人员的广泛关注，它帮助从业者实现高效率的代码版本管理，大大提高开发效率 Git广泛运用于对脚本文件的管理，但是对于word，excal，powerpoint等非脚本文件的管理，Git却无能为力 Git安装因为笔者的设备为一台windows电脑与一台linux系统的服务器，所以笔者在这里只提供Windows 和 linux的安装教程，macos系统的安装过程与windows一样，在这就不再赘述了。 windows安装直接官网安装，打开官网自动推荐适合的版本，安装包next到底就可以 git官网 安装好之后里面会有一个git文件夹里面会有一个程序叫做 git bush. 这个 git bush 是 git 在 Windows 上为了方便使用所设置的一个 Unix 的环境. 如果你是 Windows 用户, 之后的教程你也能用这个来学习使用 git. linux安装使用 Linux 的朋友们, 大家肯定都很熟悉怎么在 Linux 上装东西, 所以只要找到你的 Terminal, 并输入以下指令就可以啦: 12345# 如果你的 Linux 是 Ubuntu:$ sudo apt-get install git-all# 如果你的 Linux 是 Fedora:$ sudo yum install git-all linux 更多版本安装教程，请看这里：git官方文档 Git配置git在使用之前，需要配置git用户名和邮箱，这样方便后期代码版本的准确溯源 在git bush界面输入如下代码 12git config --global user.name&quot;xuhaha&quot;git congig --global user.email&quot;xuhaha@163.com&quot; 这两行代码配置的用户名和邮箱均为全局变量，之后在同一台设备建立仓库默认的用户名就为这个，无需再次设置。 12git config user.namegit config user.email 这两行代码为查询用户名和邮箱，用来检验用户名和邮箱配置是否正确 Git运行流程git运行流程为，在本地创建一个文件夹，作为版本库，这就是我们本地的工作空间，在这个空间中对文件进行一系列操作。之后将修改好的文件添加到缓存区，文件在缓存区中做最后一步的准备，准备被提交到本地仓库。 创建版本库（workspace）在此，版本库就是工作空间，工作空间就是版本库 我们先确定将文件放在哪个文件夹管理，比如我们在桌面新建一个文件夹，命名为gitTest，然后在Terminal或者git bush中打开这个文件夹，之后在文件夹中建立git管理文件 打开目标文件夹： 1cd ~/desktop/gitTest 创建版本库： 1git init 此时，文件夹中多了一个隐藏文件夹 .git 这就是一个空的git管理库 添加文件到缓存区(index)我们继续在文件夹里创建一个新文件，可以直接拖进来现有文件，也可以用命令行生成一个人新文件 1touch 1.py 现在我们用git status查看版本库的状态 12345678910111213$ git status# 输出On branch master # 在 master 分支Initial commitUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) 1.py # 1.py 文件没有被加入版本库 (unstaged)nothing added to commit but untracked files present (use &quot;git add&quot; to track) 现在 1.py 并没有被放入缓存区中 (unstaged), 所以我们要使用 add 把它添加进缓存区 (staged) 1234567891011121314$ git add 1.py# 再次查看状态 status$ git status# 输出On branch masterInitial commitChanges to be committed: (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage) new file: 1.py # 版本库已识别 1.py (staged) 如果想一次性添加文件夹中所有未被添加的文件, 可以使用这个 1git add . 提交文件更改到仓库（Head）这一步骤，将我们已经更改好，并且已经添加到缓存区的文件，直接提交到仓库中。 1git commit -m &quot;create 1.py&quot;//对此次提交的描述 这一个步骤直接将缓存区中所有的脚本文件一并提交到我们本地的仓库中。 查看脚本文件提交修改记录在这一步之前，我们已经在文件夹中，也就是我们的工作空间生成了一个1.py的文件，并将文件添加到了缓存区，然后提交到了仓库。这时我们可以通过以下命令来查看我们的提交记录 1git log git bash 为我们返回以下信息 1234567$ git logcommit 5b3d0a8ca8747d499e81f90e78b50b1f1ba3870d (HEAD -&gt; master)Author: xuhaha &lt;xuhhaa@gmail.com&gt;Date: Fri Dec 18 00:08:48 2020 +0800 create 1.py 通过这一条命令，我们可以详细的知道文件的提交修改信息，提交信息中包括修改者的信息，以及修改的时间。 如果我们在本地对1.py进行一次修改，添加如下代码 1print(&quot;gitis a new software&quot;) 我们将1.py文件再次添加到缓存区，并提交到仓库，之后运用log可以看到如下的修改信息： 12345678910111213$ git logcommit 111e648cef761980f1fb95b2b2dceecdcc1e03e3 (HEAD -&gt; master)Author: xuhaha &lt;xuhhaa@gmail.com&gt;Date: Fri Dec 18 00:15:08 2020 +0800 change 1commit 5b3d0a8ca8747d499e81f90e78b50b1f1ba3870dAuthor: xuhaha &lt;xuhhaa@gmail.com&gt;Date: Fri Dec 18 00:08:48 2020 +0800 create 1.py 现在我们就能看到 create 1.py 和 change 1 这两条修改信息了. 而且做出这两条 commit 的 ID, 修改的 Author, 修改 Date也被显示在上面. 查看文件修改前后的不同与仓库中的文件对比还没有add到缓存区如果在本地修改后的脚本文件还没有添加到缓存区，我们想知道此时的脚本文件和上一个已经提交的文件有何不同，我们可以使用以下命令来查看区别，在查看之前，我们先在脚本文件中作出一些修改，我们在文件中添加a=2这一条语句 1git diff 运行上面这条命令，我们可以获得以下信息 12345678910111213$ git diffdiff --git a/1.py b/1.pyindex 507924c..ab4fd96 100644--- a/1.py+++ b/1.py@@ -1 +1,2 @@-print(&quot;gitis a new software&quot;)\\ No newline at end of file+print(&quot;gitis a new software&quot;)^M+a=2\\ No newline at end of file 上面的信息就显示出来了，和上一次提交的版本相比，我们又多加了一条语句 add到缓存区如果我们已经将修改过后的文件添加到了缓存区，我们可以在diff后添加–cached来查看修改 123456789101112$ git diff --cacheddiff --git a/1.py b/1.pyindex 507924c..ab4fd96 100644--- a/1.py+++ b/1.py@@ -1 +1,2 @@-print(&quot;gitis a new software&quot;)\\ No newline at end of file+print(&quot;gitis a new software&quot;)^M+a=2\\ No newline at end of file 与缓存区中的文件对比还有种方法让我们可以查看 add 过和 没 add 的修改, 比如我们再修改一下 1.py 但不 add: 123print(&quot;gitis a new software&quot;)a=2b=3 目前第一，二条两条语言已经被add，第三条语言为新的修改，还没有被add 我们可以通过以下命令查看add和为被add的区别 1git diff HEAD 1234567891011121314$ git diff HEADdiff --git a/1.py b/1.pyindex 507924c..810d217 100644--- a/1.py+++ b/1.py@@ -1 +1,3 @@-print(&quot;gitis a new software&quot;)\\ No newline at end of file+print(&quot;gitis a new software&quot;)^M+a=2^M+b=3\\ No newline at end of file 为了以下内容进行，我们将全部内容提交到仓库，并对这次提交描述为change 2 文件属性的划分在此我插一句，在之前你可能会看到文章出现staged unstaged等字样，这些字样描述的是文件此时被修改后所处的不同位置，被修改后的版本是在仓库中还是在缓存区，或者是在我们的工作空间，这样的描述字眼一共有四个，在此我一一解释： untracked：此时被修改的文件存放在工作空间中，还没有add到缓存区，也没有commit到仓库中。 staged：此时被修改的文件已经add到了缓存区，但是此时还没有commit到仓库中。 Unmodified：此时被修改的文件已经commit到了仓库，并且文件保持着未被修改的状态 modified:当文件已经被保存到仓库中，此时文件仅仅被修改了，文件就会转化为此状态 modified和unstracked的区别：文件别修改，若文件的修改前版本没有在仓库中，则显示unstracked状态，若文件的修改前版本在仓库中，则显示modified状态。 修改已经提交的版本在写代码的时候，有时我们一走神就会忘记一些什么。比如我们已经将缓存区里面的文件commit提交到了仓库中，文件也已经变成了unmodified状态。这时我们发现有一个附加文件忘记提交到仓库中，或者这时我们提交之后紧接着修改了源代码，我们此时又不想重复提交，增加修改记录，这时我们就可以通过下面一条命令，将文件提交到上一次的修改记录。 1git commit --amend --no-edit #&quot;--no-edit&quot;: 不编辑, 直接合并到上一个 commit 在提交之前我们先对文件做出一点改变，我们将1.py文件复制一个副本出来，命名为2.py，同时我们也对1.py文件做出更改，添加以下命令。 1c=4 运行添加，提交命令，并用git log查看，得到如下反馈 1234$ git log --oneline # &quot;--oneline&quot;: 每个 commit 内容显示在一行689d32f (HEAD -&gt; master) change 2111e648 change 15b3d0a8 create 1.py 将缓存区的文件拉出来有时我们已经将文件添加到了缓存区，但是我们突然还想补充一些内容再将文件添加到缓存区，我们还可以通过以下的方式回到add以前，比如我们在1.py中添加这样的一行 1d=5 然后将文件添加到缓存区，再返回到add之前 12345678910111213$ git add 1.py$ git status -s # &quot;-s&quot;: status 的缩写模式# 输出M 1.py # staged-----------------------$ git reset 1.py #reset 将文件从缓存区拉出来，就是从staged到modified# 输出Unstaged changes after reset:M 1.py-----------------------$ git status -s# 输出 M 1.py # unstaged 回到之前提交的版本有时候，我们的代码可能越写越糟糕，如果我们想回到更改之前的某一次提交版本，怎么办呢，这时我们可以通过reset实现版本穿越，接下来看看如何实现版本穿越。 在穿梭到过去的版本之前，我们必须要了解一下git是如何一步一步累加更改的，我们截取网上的一些图片。 master不用管什么意思，在下面的内容中会讲解到master是什么 通过git log --oneline命令我们可以查看到，我们的每一次提交都有id号码，HEAD是一个指针，学习过c语言的同学应该对指针不陌生，指引当前的状态在哪一次提交，最进的一次提交在commit的最右面，了解原理，实现版本穿梭就不难了，我们可以调整指针HEAD的位置，回到过去的版本。 1234567891011121314151617181920#通过以下命令查看当前HEAD指针所在的位置$ git reset --hard HEADHEAD is now at 689d32f change 2#查看所有的修改记录$ git log --oneline0e69ed4 (HEAD -&gt; master) change 2111e648 change 15b3d0a8 create 1.py# 回到 111e648 change 1# 方式1: &quot;HEAD^&quot;$ git reset --hard HEAD^ # 方式2: &quot;commit id&quot;$ git reset --hard 111e648# 看看现在的 log$ git log --oneline# 输出111e648 change 15b3d0a8 create 1.py 此时我们发现change 2消失不见了，我们还有办法补救消失的change 2吗？ 我们可以通过git reflog查看HEAD的所有改动，我们可以再次通过reset回到change 2这一步了 因为我的HEAD记录记录在写教程之前就变动了多次，产生了众多的记录，所以我就借此说一说HEAD作为指针是如何工作的。 123456789101112131415161718$ git reflog689d32f (HEAD -&gt; master) HEAD@{0}: reset: moving to 689d32f0e69ed4 HEAD@{1}: reset: moving to 0e69ed4689d32f (HEAD -&gt; master) HEAD@{2}: reset: moving to HEAD689d32f (HEAD -&gt; master) HEAD@{3}: reset: moving to 689d32f0e69ed4 HEAD@{4}: reset: moving to 0e69ed4689d32f (HEAD -&gt; master) HEAD@{5}: reset: moving to 689d32f5b3d0a8 HEAD@{6}: reset: moving to HEAD5b3d0a8 HEAD@{7}: reset: moving to 5b3d0a85b3d0a8 HEAD@{8}: reset: moving to HEAD^111e648 HEAD@{9}: reset: moving to HEAD^689d32f (HEAD -&gt; master) HEAD@{10}: reset: moving to HEAD689d32f (HEAD -&gt; master) HEAD@{11}: commit (amend): change 2b155394 HEAD@{12}: commit (amend): change 20e69ed4 HEAD@{13}: commit: change 2111e648 HEAD@{14}: commit: change 15b3d0a8 HEAD@{15}: commit (initial): create 1.py 通过git reflog查看所有的指针移动记录，我们发现记录虽然有很多条，但是提交版本的id不变，反反复复就那几个重复出现，这是因为提交版本的id就直接引用了内存的地址编码，这样就更好的理解了HEAD作为指针是如何移动的了。最后一条记录也显示，我们最终回到了change 2. 将单个文件回到过去版本我们现在知道了，如果想回到之前的提交版本，我们可以利用reset回到之前我们已经提交的任意一个版本，但是如果我们只想对工作空间中的其中一个文件实现版本穿梭，而其他文件保持当前的版本不变，我们应该怎么做呢？这时我们就可以通过checkout来实现。 我们仅仅要对1.py实现版本穿梭的操作，回到change 1这一个提交版本，使用git checkout+111e648 +-- 1.py我们就可以调整1.py的指针回到change 1. 1234567$ git log --oneline689d32f (HEAD -&gt; master) change 2111e648 change 15b3d0a8 create 1.py$ git checkout 111e648 -- 1.py 此时我们打开文件就会发现，1.py的文件内容已经变成了change 1时的信息。 1print(&quot;gitis a new software&quot;) 我们在 1.py 加上一行内容 # I went back to change 1 然后 add 并 commit 1.py: 123456789$ git add 1.py$ git commit -m &quot;back to change 1 and add comment for 1.py&quot;$ git log --oneline#输出23e5b56 (HEAD -&gt; master) back to change 1 and add comment for 1.py689d32f change 2111e648 change 15b3d0a8 create 1.py 可以看出, 不像 reset 时那样, 我们的 change 2 并没有消失, 但是 1.py 却已经回去了过去, 并改写了未来. 这就是reset和checkout的区别 分支（branch）git 的分支就像树的树枝一样，不同的分支下有不一样的脚本文件，我们在这之前做的所有的修改都是在master分支上进行的，我们可以在创立一个分支development，将代码稳定版本放在master上，将我们的开发版本放在dev上，这样就方便我们通过一个文件，实现对不同版本的管理。 查看分支在此之前我们只有一个分支master，我们可以通过以下命令来查看现有的分支，及其所包含的文件。 1234567891011$ git log --oneline --graph* 23e5b56 (HEAD -&gt; master) back to change 1 and add comment for 1.py* 689d32f change 2* 111e648 change 1* 5b3d0a8 create 1.py$ git log --oneline23e5b56 (HEAD -&gt; master) back to change 1 and add comment for 1.py689d32f change 2111e648 change 15b3d0a8 create 1.py 通过对比两次输出结果我们可以发现，添加–graph后，文件前面多了*号。 *号代表的就是主分支的意思。 创建分支123456$ git branch dev # 建立 dev 分支$ git branch # 查看当前分支# 输出 dev * master # * 代表了当前的 HEAD 所在的分支 切换分支当我们想把HEAD切换到dev去的时候，我们可以用到之前所说的checkout： 123456$ git checkout devSwitched to branch 'dev'$ git branch* dev#此时HEAD已经切换到了dev分支 master 这里我们还可以通过一种方法直接创建并切换到新建的分支 使用 checkout -b + 分支名, 就能直接创建和切换到新建的分支: 12345678910$ git checkout -b dev# 输出Switched to a new branch 'dev'--------------------------$ git branch# 输出* dev # 这时 HEAD 已经被切换至 dev 分支 master 在其他分支中修改dev 分支中的 1.py 和 2.py 和 master 中的文件是一模一样的. 因为当前的指针 HEAD 在 dev 分支上, 所以现在对文件夹中的文件进行修改将不会影响到 master 分支. 我们在 1.py 上加入这一行 # I was changed in dev branch, 然后再 commit: 1$ git commit -am &quot;change 3 in dev&quot; # &quot;-am&quot;: add 所有改变 并直接 commit 将 dev 的修改推送到 master好了, 我们的开发板本 dev 已经更新好了, 我们要将 dev 中的修改推送到 master 中, 大家就能使用到正式版中的新功能了. 首先我们要切换到 master, 再将 dev 推送过来. 1234567891011$ git checkout master # 切换至 master 才能把其他分支合并过来$ git merge dev # 将 dev merge 到 master 中$ git log --oneline --graph# 输出* f9584f8 change 3 in dev* 47f167e back to change 1 and add comment for 1.py* 904e1ba change 2* c6762a1 change 1* 13be9a7 create 1.py 要注意的是, 如果直接 git merge dev, git 会采用默认的 Fast forward 格式进行 merge, 这样 merge 的这次操作不会有 commit 信息. log 中也不会有分支的图案. 我们可以采取 --no-ff 这种方式保留 merge 的 commit 信息. 123456789101112$ git merge --no-ff -m &quot;keep merge info&quot; dev # 保留 merge 信息$ git log --oneline --graph# 输出* c60668f keep merge info|\\ | * f9584f8 change 3 in dev # 这里就能看出, 我们建立过一个分支|/ * 47f167e back to change 1 and add comment for 1.py* 904e1ba change 2* c6762a1 change 1* 13be9a7 create 1.py Githubgithub是非常强大的开源社区，我们可以将我们的文件从我们的本地仓库上传到云端服务器进行管理 github使用包括以下几个步骤 git在第一次尝试与github服务器连接的时候，会让你进行github登录，这时登录自己的账号就可以了，以后在这台电脑上与github连接就无需再次登陆了 克隆仓库： 123#新建文件夹，并在文件夹下创建新仓库git initgit clone url #url为被克隆仓库地址 推送文件到github仓库： 1234567#如果已经克隆现有仓库git push origin master#可以把master换成任何分支#没有克隆现有仓库，并欲将你的仓库连接到github远程服务器#你可以在本地使用如下命令添加github服务器：git remote add origin url.git #url为仓库地址git push origin master 将github服务器文件拉进本地目录 1git pull 参考文献： git - 简易指南 Pro Git（中文版） 莫烦python，Git 版本管理","link":"/2020/12/17/Git%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"title":"关于喜欢，这一情感”","text":"b站上一位作家，引发了我一点点的思考 ​ 哲学，是研究世界的一门学科，研究哲学有一个非常明确的观点就是，一个观点，无论你认为有么的荒谬，也不要直接去否定它。你首先要做的应该是，先去了解他提出的这个观点，了解提出观点的背景，了解提出这个观点的原因，进而对他发表你自己的看法。发表言论的前提，是我们需要对这件事情有足够的认识，在如今互联网时代更是如此，做一个合格网民的前提是要做一名合格的读者，在网络上时刻保持清醒，时刻保持独立思考。 ​ 关于喜欢，喜欢的对象可以是人，可以是领域，可以是任何物质，我之前在b站看到一个视频，视频的作者是一名文字工作者，作者非常喜欢写作，在视频里他谈到了这么多年他与写过的缘分，他说当他在写作的时候，他会感觉非常放松，在学生期间，他每天最放松的事情就是躺在床上，构思他的小说内容，可以看出来，这位作者非常喜欢写作，但是当时我听到这段的时候，我就在想，喜欢对一个人的影响这有这么大吗，直到我发现自己喜欢的领域是计算机的时候，我才突然明白作者当时的感受，原来，尽早的找到自己喜欢的事物，真是非常幸福的一件事，对于喜欢的事情，内心会不自觉的为它设立目标，在繁忙的日子里，每天最期待的事情就是自己喜欢的事情，真的就像孔子所说，“知之者不如好之者，好之者不如乐之者”。孔子的这句话也警醒着我们广大的青年朋友，在未来的人生规划，职业选择上，甚至是高考报志愿，对于行业的选择 ，对于专业的选择，喜欢才是选择的决定性标准，我们这一辈子应该追求的，也不止是金钱。根据二八定律，平凡的人永远占据着世界的八成。做自己所爱，不为金钱左右自己的热爱，在自己所热爱的行业里爱的彻底，走只属于自己的道路，在自己的道路上走到极致，人生一样会非常精彩，还会精彩的与众不同","link":"/2020/12/19/%E5%85%B3%E4%BA%8E%E5%96%9C%E6%AC%A2%EF%BC%8C%E8%BF%99%E4%B8%80%E6%83%85%E6%84%9F%E2%80%9D/"},{"title":"编程自学之路（持续更新中）","text":"我个人的编程自学指南，我会在这里记录我自学编程路上的点点滴滴 2021年自学之路 整体计划以年和月作为计划分界 实际行动以周和天进行执行和总结 年目标： 英语一年达到雅思水平，目标7.5分，可以进行基本交流以及文献阅读（最后附雅思考试日历） 阅读50本以上图书 中英文打字速度和打字准确率需要提高（最后附打字提升网站） 趁学生时代时间多，着力学习计算机基础（计算机网络，操作系统，计算机组成原理，c，c++，java，python） 数学基础学习：线性代数，微积分，概率论，离散数学 数学建模及matlab 蓝桥杯python算法比赛 健身，矫正驼背和颈椎 月目标：一月： 读四本书，编写至少两篇读书笔记 《the secret》、《小狗钱钱》 《穷爸爸，富爸爸》、《财富自由之路》 小猪佩奇，第一季，前二十集完成对英语听的训练 计划共花费二十二小时练习打字，共二十二天 学完线性代数 学完数据结构，学透学精 尝试完成智能优化算法的九分之四 坚持一周五次运动，争取每天跟着周六野老师做颈椎恢复 二月： 读四本书，编写至少两篇读书笔记 小猪佩奇，第一季，剩余二十五集完成对英语听的训练 计划共花费二十八小时练习打字，共二十八天 尝试完成智能优化算法的九分之五 学完微积分 学完计算机基础及组成原理，学透学精 坚持一周五次运动，争取每天跟着周六野老师做颈椎恢复 三月： 读四本书，编写至少两篇读书笔记 小猪佩奇，第一季剩余七集，第二季剩余二十集完成对英语听的训练 听单词，看单词，这个计划在二月底待定 学完概率论 坚持一周五次运动，争取每天跟着周六野老师做颈椎恢复 四月： 读四本书，编写至少两篇读书笔记 小猪佩奇，第二季，剩余二十六集完成对英语听的训练 学完离散数学 坚持一周五次运动，争取每天跟着周六野老师做颈椎恢复 五月： 读四本书，编写至少两篇读书笔记 小猪佩奇，第二季剩余七集，第三季剩余二十集完成英语听的训练 坚持一周五次运动，争取每天跟着周六野老师做颈椎恢复 六月： 读四本书，编写至少两篇读书笔记 小猪佩奇，第三季，剩余二十六集完成对英语听的训练 坚持一周五次运动，跟着周六野老师做颈椎恢复 七月： 读四本书，编写至少两篇读书笔记 小猪佩奇，第三季剩余六集，第四季剩余二十一集完成对英语听的训练 坚持一周五次运动，跟着周六野老师做颈椎恢复 八月： 读四本书，编写至少两篇读书笔记 小猪佩奇，第四季，剩余三十一集完成对英语听的训练 坚持一周五次运动，跟着周六野老师做颈椎恢复 九月： 读四本书，编写至少两篇读书笔记 坚持一周五次运动，跟着周六野老师做颈椎恢复 十月： 读四本书，编写至少两篇读书笔记 坚持一周五次运动，跟着周六野老师做颈椎恢复 十一月： 读四本书，编写至少两篇读书笔记 坚持一周五次运动，跟着周六野老师做颈椎恢复 十二月： 读四本书，编写至少两篇读书笔记 坚持一周五次运动，跟着周六野老师做颈椎恢复 附件打字网站：www.typingclub.com雅思考试日历：","link":"/2020/12/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/"},{"title":"如何迅速成为某一领域的高手","text":"比较优势是普通人逆袭的捷径 如何成为某一领域的高手呢，最简单有效的办法就是向某一领域中的高手学习，因为自学就像爬楼梯，跟着老师学就像坐飞机，有了老师的引导，学习效率就会事半功倍。 可是问题来了，高手为什么会愿意教你呢？这时候我们就要需要用到比较优势了。 比较优势是经济学名词，了解比较优势之前我们先要了解一下什么是机会成本，机会成本是指我们做一个选择后所丧失的不做该选择而可能获得的最大利益。简单的讲就是鱼和熊掌不可兼得的道理，我们如果选择上大学，我们就放弃了去搬砖赚钱的机会，这就是机会成本。比较优势就是指一个生产者低于另一个生产者的机会成本生产某有一种物品的行为。 由于有机会成本的存在，所以没有任何一个人在需要解决的所有事情上都具有比较优势，领域中的高手也一样，有很多事情在他们看起来低效简单，他们也就不愿意花费时间精力来处理这些事情，这时他就会选择外包这些事情，将自己的精力和时间投入到更高效的生产中。我们就可以利用我们自身的比较优势，选择帮助高手处理这些不需要太多能力就可以解决的事情，我们为高手提供价值。高手为我们提供机会接近他，观察他，我们进而反思自己和高手的差距，慢慢的日积月累，你也会成为领域中的高手。 国内有一家小有名气的影视工作室，工作室的创始人在读大学期间，利用自身的比较优势，主动为当时一家成绩显著的影视工作室做免费劳动力，他每周利用两天时间去那家工作室免费实习，他不断地学习，反思与高手的差距，慢慢经过时间的沉淀，他现在也拥有了一家小有名气的影视工作室。 最后还要说一点，比较优势虽然是普通人逆袭的捷径，但是过程一点也不容易，需要很明确的目标和很坚韧的心理素质。","link":"/2020/12/26/%E5%A6%82%E4%BD%95%E8%BF%85%E9%80%9F%E6%88%90%E4%B8%BA%E6%9F%90%E4%B8%80%E9%A2%86%E5%9F%9F%E7%9A%84%E9%AB%98%E6%89%8B/"},{"title":"【计算机学习】《大话数据结构》学习笔记","text":"笔者目前是一名自动化专业的本科生，开设自学计算机这个系列完全是因为兴趣使然，我会在这个系列里面更新我在自学计算机路上的点点滴滴以及我走过的坑，欢迎各位朋友添加我的个人微信一起交流学习。 本书采用的高级语言为c语言，除了用c语言实现书中内容，还可尝试用python来实现书中内容 第一遍学习，从头到尾全部学完，重复学习，建立知识体系 学习时，摘抄是非常好的习惯 学习每一章时，一定要将代码在电脑上运行一遍 学习完每一章，都要配合适当练习 学习数据结构不要只认准一本书，多看一些优秀书目 在开发中尝试使用数据结构 第1章 数据结构绪论对于学习，我们要有求甚解的精神。现在好多的算法都有对应函数完美的实现，但是我们还是要继续弄懂算法的原理，从模仿到创新，学习就是这个过程。因为开车和造车是两件完全不同的事情。算法和数据结构的学习更是如此。 基本概念和术语数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。 可以输入到计算机中 能被计算机程序处理 数据元素：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。 数据项：一个数据元素可以由若干个数据项组成。 数据项是数据不可分割的最小项 数据对象：是性质相同的数据元素的集合，是数据的子集。 数据结构：是相互之间讯在一种或多种特定关系的数据元素的集合 逻辑结构 集合结构：集合结构中的数据元素除了同属于一个集合外，他们之间没有其他关系。 线性结构：线性结构中的数据元素之间是一对一的关系。 树形结构：树形结构中的数据元素之间存在一种一对多的层次关系。 图形结构：图形结构的数据元素是多对多的关系。 物理结构物理结构也叫存储结构，顾名思义是数据的逻辑结构在计算机内存中的排列方式 顺序存储结构：是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系一样。 链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。 逻辑结构面向问题，而物理结构面向的是计算机，其基本目的就是将数据及其逻辑结构存储在计算机内存中 抽象数据类型数据类型：是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。 例如：整形、实形、数组 抽象是指抽出事物具有的普遍性的本质。抽象是一种思考问题的方式，他隐藏了繁杂的细节，只保留实现目标所必需的信息。 抽象数据类型：是指一个数据模型及定义在该模型上的一组操作。 对数据概念可以这样总结。现在有一份文档，里面记录了社区全部居民的核酸检测报告，这份文档报告就是数据，里面的社区全部居民核酸检测报告就是数据对象，每一位居民的核酸检测报告就是数据元素，检测报告中又包括姓名，年龄，身份证号，检测结果等信息，这些个人信息就是数据项。 抽象数据类型就像是Java或者python中的类以及c语言中的类。 第2章 算法数据结构和算法就像罗密欧与朱丽叶，二者缺一不可，缺少任何一方，另一方学习起来就如同味如嚼蜡。 算法就是解决问题的步骤。 算法的特性 输入输出 算法的输入可以是零个，但是输出至少要有一个（如果没有输出，则算法的存在将毫无意义）。 有穷性 算法都可以在有限的循环中结束，不会进入死循环，一直运行下去。这里的又穷也不只是纯数学意义，如果一个算法，计算机要运行20年，这个算法存在的意义也就不大了。 确定性 算法的每一个步骤都有确定的意义，算法的每一步骤确定定义而无异议（相同的输入只能有唯一的输出结果）。 可行性 算法的每一个步骤都是可行的，也就是说，每一步都不是死循环。 算法的设计要求 正确性 正确性体现在这四个层次，算法中没有语法错误，算法对合法输入能够产生合理的结果，算法对非法的输入产生合理的说明，算法还能应付刁钻，精心挑选的测试数据 可读性 便于阅读 理解 和交流 健壮性 当输入的数据不合法时，算法也能做出相关处理，而不是产生异常或者莫名其妙的结果。 使用效率高，存储量低 花最少的内存，用最少的时间，办一件大事（时间复杂度和空间复杂度都要低）。 算法效率的度量方法事后统计法：计算运行时间。 这种方法有很多缺陷，受客观因素影响太多。 事前分析估算法：在计算机程序编制前，对算法进行估算。 一个程序运行的时间，依赖于算法的好坏，和问题输入的规模。 函数的渐近增长给定两个函数f（x）和g（x），如果存在一个整数N，使得对于所有的n&gt;N，f总是比g大，那么我们说f的渐进增长快于g。 判断一个算法的效率时，函数中的常数项和其他次要项可以忽略，而更应该关注最高项的阶数。 算法时间复杂度时间复杂度的公式是：T(n) = O( f(n) )，其中f(n) 表示每行代码执行次数之和，而 O 表示正比例关系，这个公式的全称是：算法的渐进时间复杂度。 用大写O表示的记法叫做大O记法，随着n的增大，T（n）增长最慢的算法为最优算法。 推导大O阶： 用常数1取代运行时间中的所有加法常数。 在修改的运行次数函数中，只保留最高阶。 如果最高阶存在且不是1，则除去与这个项相乘的常数。 除非特别指定，否则我们提到的运行时间都是最坏情况的运行时间。 一般没有特殊说明，都是指最坏时间复杂度。 算法空间复杂度空间复杂度的公式是：S(n) = O( f(n) )，用来计算算法所占的储存空间。 用好算法分析工具，改进自己的代码，让自己更加胜人一筹。 第三章 线性表 线性表是零个或多个数据元素的有限序列。线性表就像排队一样，一个接着一个，从头排到尾。结合第一单元的知识我们可以知道，线性结构是线性表的逻辑结构，它可以通过两种物理结构来实现，一种是顺序存储结构，一种是链式存储结构。 线性表的顺序存储结构定义：线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素 线性表顺序存储结构代码： 1234567#define MAXSIZE 20 typedef int ElemType;typedef struct{ ElemType data[MAXSIZE]; int length;}SqList; ElemType代表的是数据元素的类型，这里定义的是int类型。 我们将线性表用一维数组实现，并将线性表的数据元素长度等相关数据打包为结构体。 这里要注意，线性表的长度不一定等于数组的长度，就像被子里面的水不一定等于杯子的容量，所以我们声明了一个变量length单独记录线性表的长度。 存储器中每一个存储单元都有自己的编号，这个编号称为地址，在这里一维数组的地址为0-MAXSIZE-1。 线性表获得元素操作： 123456789101112#define OK 1#define ERROE 0#define TRUE 1#define FALSE 0typedef int Status;Status GetElem(SqList L,int i ,ElemType *e){ if (L.length==0 || i&lt;1 || i&gt;L.length) return ERROE; *e=L.data[i-1]; return OK;} 在进行获取元素操作前，提前定义了一些常量，这些常量运用到程序中起到方便阅读的作用。 对抽象数据类型的每一次操作都要说明初始条件和操作结果。 初始条件：线性表L存在，并且i合理 操作结果：用指针e返回L中第i个数据元素的值。 线性表插入操作： 12345678910111213141516Status ListInsert(SqList *L,int i , ElemType e){ int k; if(L-&gt;length==MAXSIZE) return ERROE; if(i&gt;L-&gt;length+1||i&lt;1) return ERROE; if(i&lt;=L-&gt;length){ for(k=L-&gt;length-1;k&gt;=i-1;k--) L-&gt;data[k+1]=L-&gt;data[k]; } L-&gt;data[i-1]=e; L-&gt;length++; return OK;} 初始条件：线性表L存在（有空位置），并且i合理 操作结果：在L中第i个元素前插入新的数据元素e，L的长度加1。 算法比较简单，算法的思路在最后的总结中一并讲起。 线性表删除操作： 123456789101112131415Status ListDelete(SqList *L,int i,ElemType *e){ int k; if(L-&gt;length==0) return ERROE;· if(i&lt;1||i&gt;L-&gt;length) return ERROE; *e=L-&gt;data[i-1]; for(k=i-1;k&lt;L-&gt;length-1;k++) { L-&gt;data[k]=L-&gt;data[k+1]; } L-&gt;length--; return OK;} 初始条件：线性表L存在（有数据可以删除），并且i合理 操作结果：删除L中的第i个元素，并用e返回其值，L的长度减一。· 算法比较简单，算法的思路在最后的总结中一并讲起。 算法思路总结： 线性表获取，插入，删除操作的思路 如果进行的操作不合理，则抛出异常，在这一步将所有的不合理输入情况用if写入算法中，并返回error。（线性表的操作不合理主要有对满的线性表，对空的线性表进行操作，以及操作范围超出线性表的长度） 操作合理，则进行操作 删除和插入操作中，i代表的是数据元素的位置，数据元素从1开始计数，k代表的是数据元素在数组中的位置，数组从0开始计数。这点要注意。 线性表的链式存储结构定义：这种存储结构就是c语言中的链表，数据元素中除了存储数据的数据域以外，还要有存储后继位置的地址的指针域。这两部分称为数据元素的存储映像，称为结点。 链表的第一个结点叫做头结点。头结点的地址位置叫做头指针。头指针是链表的必要元素，而头结点不是。但是还是建议在链表中，加上头结点，这样对第一个数据元素的修改就和其他元素的修改操作统一了。 线性表链式存储结构： 123456typedef struct Node{ ElemType data; struct node *next;} Node;typedef struct Node *LinkList; 单链表的读取： 123456789101112131415161718Status GetElem(LinkList L,int i ,ElemType *e){ int j; LinkList p; p=L-&gt;next; j=1; while(p-&gt;next!=NULL) { if(j==i) { *e=p-&gt;data; return OK; } p=p-&gt;next; j++; } return ERROE;} 初始条件：链表L存在，且i在合理的范围。 操作结果：用e返回L中第i个数据元素。 因为L为有头结点链表，所以在此我们将生成一个循环节点p，用于遍历链表， p=L-&gt;next;，此时p就位于第一个数据元素或者NULL上。 在这个算法上，只有找到输出ok，其余情况下一律输出error。 单链表的插入： 123456789101112131415161718192021Status ListInsert(LinkList *L,int i,ElemType e){ int j; LinkList p,s; p=*L; j=1; while(p&amp;&amp;j&lt;i) { p=p-&gt;next; j++; } if(!p||j&gt;i) { return ERROE; } s=(LinkList)malloc(sizeof(Node)); s-&gt;next=p-&gt;next; p-&gt;next=s; s-&gt;data=e; return OK;} 初始条件：链表L存在，且i在合理的范围。 操作结果：在L中第i个位置之前插入新元素e，并将L的长度加1. 此算法的核心为s-&gt;next=p-&gt;next；p-&gt;next=s;这两句话不可颠倒，若不理解可以通过画图的方式快速理解两句语句。 算法中还用malloc函数为s开辟了一块内存空间。 插入算法与读取算法均应用了链表的遍历过程，但是遍历的代码并不一样，两者皆可用于链表遍历，两者都采用了判断边界条件的同时遍历算法。判断边界条件的方式：在用指针变量之前，要有足够的证据证明指针变量不是NULL。 单链表的删除： 123456789101112131415161718192021Status ListDelete(LinkList *L,int i,ElemType *e){ int j; LinkList p,q; p=*L; j=1; while(p&amp;&amp;j&lt;i) { p=p-&gt;next; j++; } if (!p||j&gt;i) { return ERROE; } q=p-&gt;next; p-&gt;next=q-&gt;next; *e=q-&gt;data; free(q); return OK;} 初始条件：线性表L存在，并且i合理 操作结果：删除L中的第i个元素，并用e返回其值，L的长度减一。 此算法中核心语句就两条q=p-&gt;next;p-&gt;next=q-&gt;next;，这两句话同样也不可以颠倒，若颠倒则p后语句全部消失。 算法思路总结： 不同于顺序存储结构，链式存储结构抛出异常的条件很简单，如果遍历过程中找不到需要结点，就抛出异常。所以单链表操作算法就两个步骤组成：遍历查找元素，操作元素。 找到结点后，进行我们的相应操作。 读取算法和插入删除算法除具体操作外，主要区别在于遍历的方式不同，以及算法传入的链表形式不同。读取算法传入的是链表的副本，在操作中无论对链表做什么操作，都不会影响我们全局链表的内容。而插入和删除操作传入的是链表的头指针，所以我们的操作就相当于是在全局链表上动刀。 链式存储结构，判断边界条件的方式：在用指针变量之前，要有足够的证据证明指针变量不是NULL。 线性表两种存储结构比较 顺序存储结构优点在于可以快速存取表中的数据，缺点在于不便于进行大量数据插入或者删除操作 链式存储结构优点在于对插入或者删除数据的操作很方便，但是每次查找数据都要从头遍历元素 在空间性能上，顺序存储结构需要预分配存储空间，分大了浪费，分小了容易发生数据溢出。 对于插入和删除操作越频繁的操作，单链表的优势就越明显。 我在此设想了一种数据存储模式应对频繁插入删除数据，以及频繁查找数据的情况是：用线性表的链式结构应付频繁的插入和删除操作，并及时将链式存储结构的数据克隆一份顺序存储结构，这样就可以在频繁的插入和删除操作的同时，快速读取数据。缺点是算法的空间复杂度增加。 单链表的其他操作 单链表的整表创建 ​ 有时我们经常会给计算机一组数据，让其帮助我们生成一串链表，这时我们就涉及到了单链表的整表创建问题，单链表的整表创建分为头插法和尾插法。 ​ 单链表头插法是将每一个新结点加入头结点的后面，这种数据结构有点类似于栈，后进的数据位于前面 单链表的整表创建（头插法）： 123456789101112131415void CreateListHead(LinkList *L,int n){ LinkList p; int i; srand(time(0)); *L=(LinkList)malloc(sizeof(Node)); (*L)-&gt;next=NULL; for (i=0;i&lt;n;i++) { p=(LinkList)malloc(sizeof(Node)); p-&gt;data=rand()%100+1; p-&gt;next=(*L)-&gt;next; (*L)-&gt;next=p; }} 单链表的整表创建，输入为链表的头指针*L，程序中先为头指针生成一个头结点。 p-&gt;next=(*L)-&gt;next； (*L)-&gt;next=p;这两句语句就是将新生成的结点插入头结点之后 单链表的整表创建（尾插法）： 1234567891011121314151617void CreateListTail(LinkList *L,int n){ LinkList p,r; int i; srand(time(0)); *L=(LinkList)malloc(sizeof(Node)); r=*L; for (i=0;i&lt;n;i++) { p=(Node*)malloc(sizeof(Node)); p-&gt;data=rand()%100+1; r-&gt;next=p; r=p; } r-&gt;next=NULL;} 让r指针始终指向*L链表的最后一个结点 r-&gt;next=p;r=p;这两句语句就是将新结点插入r的后面，之后r再走向下一个指针。 单链表的整表删除 ​ 单链表的整表删除，就是将单链表的每个结点逐一在内存空间中释放，因为链式存储结构中单链表的各个结点是散落在内存中的，所以我们要逐个循环，逐个释放。 单链表的整表删除： 12345678910111213Status ClearList(LinkList *L){ LinkList p,q; p=(*L)-&gt;next; while(p) { q=p; p=p-&gt;next; free(q); } (*L)-&gt;next=NULL; return OK;} 对单链表的整表删除思路为先循环，然后一直到结尾，逐一释放结点。 在这里不要忘记，最后要将(*L)-&gt;next=NULL; 关于srand(time(0)) 和rand() 的解释计算机没有办法产生真正的随机数的，是用算法模拟，所以你只调用rand，每次出来的东西是一样的。设置一个种子后，根据种子的不同，就可以产生不同的数了。而怎么保证种子的不同呢？最简单的办法当然是用永远在向前的时间。 srand(time(0)) ;//先设置种子rand();//然后产生随机数 Srand是种下随机种子数，你每回种下的种子不一样，用Rand得到的随机数就不一样。为了每回种下一个不一样的种子，所以就选用Time(0)，Time(0)是得到当前时时间值（因为每时每刻时间是不一样的了）。 srand(time(0)) ; 就是给这个算法一个启动种子，也就是算法的随机种子数，有这个数以后才可以产生随机数,用1970.1.1至今的秒数，初始化随机数种子。 静态链表​ C语言拥有指针这一强有力的工具，因此C语言可以轻松创造出链表这样的数据结构，但是在没有指针的其他高级语言中，我们应该如何创建链表呢？有人就想出来用数组代替指针，来描述单链表。首先我们让数组元素都由两个数据域组成，data和cur，数据域data用于存放数据元素，而游标cur就相当于我们说的指针中的next指针，存放该元素的后继在数组中的下标。我们把这种用数组模拟的链表叫做静态链表。 静态链表存储结构： 12345typedef struct { ElemType data; int cur;}Component,StaticLinkList[MAXSIZE]; 数组中每一个元素都是由数据域和游标域组成。 另外我们对数组的第一个元素和最后一个元素做特殊元素处理，不存数据。我们通常把未被使用的数组元素称为备用链表。而数组第一个元素，即下标为0的元素的cur就存放备用链表的第一个结点下标；而数组中最后一个元素的cur则存放第一个有数值的元素的下标，相当于单链表中的头结点的作用，当整个链表为空时，则为0。 有些书籍会把数组的第二个元素作为头结点，实现原理相同，只是存放位置不同。我个人更偏向于将头结点安排在最后一个位置，因为这样，第一个数据元素的下标也为一。 静态链表初始化成备用链表： 123456789//静态链表初始化成备用链表Status InitList(StaticLinkList space){ int i; for (i=0;i&lt;MAXSIZE-1;i++) space[i].cur=i+1; space[MAXSIZE-1].cur=0; return OK;} 此步操作初始化链表，因为此时静态链表还未存放数据，所以整表均为备用链表。 头结点游标指向为0 静态链表插入操作： ​ 在动态链表中，结点的申请和释放分别借用malloc和free两个函数来实现，在静态链表中，因为操作对象是数组，所以不存在内存空间的申请和释放，但是我们还需要自己实现这两个函数，来做插入或者删除的操作。 ​ 静态链表的插入和删除算法思路和单链表相同，算法不同在与静态链表在数组上操作。 静态链表获取备用空间： 123456789int Malloc_SLL(StaticLinkList space){ int i=space[0].cur; if(space[0].cur) { space[0].cur=space[i].cur; } return i;} 如果静态链表还未满，将返回第一个备用空间的下标i，此时数组第一个元素游标cur下移到i的cur，若静态链表已经满了，则直接返回0。 在L中第i个元素前插入新的数据元素e 123456789101112131415161718Status ListInsert(StaticLinkList L,int i,ElemType e){ int j,k,l; k=MAXSIZE-1; if(i&gt;ListLength(L)+1||i&lt;1) return ERROE; j=Malloc_SLL(L); if (j) { L[j].data=e; for(l=1;l&lt;i-1;l++) k=L[k].cur; L[j].cur=L[k].cur; L[k].cur=j; return OK; } return ERROE;} 算法思路和单链表操作相同，插入先判断异常，插入位置是否合理，数组L中是否还有备用链表用于存放数据。 数组元素从头结点开始循环遍历，寻找第i个元素，并将元素e插入i的前面。 静态链表删除操作： ​ 和前面一样，删除元素，需要释放结点，我们得自己实现free这个函数 静态链表释放备用空间： 12345void Free_SSL(StaticLinkList space,int k){ space[k].cur=space[0].cur; space[0].cur=k;} 释放空间算法将空闲结点用头插法的方式插在备用链表上。 删除在L中第i个数据元素e： 123456789101112131415Status ListDelete(StaticLinkList L,int i){ int j,k; if (i&gt;ListLength(L)||i&lt;1) return ERROE; if (!(L[MAXSIZE-1].cur)) return ERROE; k=MAXSIZE-1; for(j=1;j&lt;=i-1;j++) k=L[k].cur; j=L[k].cur; L[k].cur=L[k].cur; Free_SSL(L,j); return OK;} 此算法的操作思路与单链表删除算法操作思路相同 静态链表的其他操作： 返回链表长度操作ListLength： 1234567891011int ListLength(StaticLinkList L){ int j=0; int i=L[MAXSIZE-1].cur; while(i) { i=L[i].cur; j++; } return j;} 这个算法的操作思路返回数据链表的长度，可将这个函数用于删除或者插入算法中，获得链表的长度。 静态链表是为没有指针的高级语言设计的一种实现单链表的方法，尽管未来不一定用的上，但是这种方法非常巧妙，应该理解其思想，以备不时之需。 循环链表将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表成为单循环链表，简称循环链表。 循环链表与单链表的差异体现在判断条件上，原来判断p-&gt;next 是否为空，现在则是p-&gt;next是否为头结点。 双向链表双向链表是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。 双向链表存储结构 1234567typedef struct DulNode{ ElemType data; struct DulNode *prior; struct DulNode *next;}DulNode,*DuLInkList; 在双向链表中，头结点的前驱指向最后一个结点，最后一个结点的后继指向头结点，这样双向链表就形成了双向循环链表。 双向链表的删除和插入操作遍历链表的方式和单链表相同，但要同时操作两个指针，这也是双向链表不同于单链表的地方。 我们现在将结点s插入到p和p-&gt;next之间，注意顺序不能错，如果不理解这四步，可以画图理解。 1234s-&gt;next=p-&gt;next;p-&gt;next-&gt;prior=s;p-&gt;next=s;s-&gt;piror=p; 我们现在将结点p删除。 123p-&gt;prior-&gt;next=p-&gt;next;p-&gt;next-&gt;piror=p-&gt;prior;free(p); 双向链表就是用空间换时间。 第四章 栈和队列栈的意思是货物存储地点、旅客的休息处，栈也可以引申为仓库的意思，在这里栈作为一种数据存储结构。栈是限定仅在表尾进行插入和删除操作的线性表。 队列顾名思义就像我们生活中的队伍。队列是只允许在一端进行插入操作、而在另一边进行删除操作的线性表。 栈栈的定义​ 栈是限定仅在表尾进行插入和删除操作的线性表。我们把允许插入和删除的一端称为栈顶（top），另一端称为栈底（bottom），不含任何数据元素的栈称为空栈。栈又称为后进先出（last in first out）的线性表，简称LIFO结构。 ​ 栈的插入操作，叫做进栈，也称压栈，入栈。 ​ 栈的删除操作，叫做出栈，也有的叫做弹栈。 栈的顺序存储结构&emsp;因为栈是线性表的特例，所以栈的顺序存储结构和线性表相同，在这里我们将下标为0的数组元素定为栈底，定义一个top变量来指示栈顶元素的位置，当栈中只有一个元素时，top为0，当栈为空时，规定top为-1 栈的顺序存储结构定义 12345typedef struct { SElemType data[MAXSIZE]; int top;}SqStack; 栈的顺序存储结构和线性表的顺序存储结构类似，唯一不同为线性表的顺序存储结构中变量记录的是线性表的长度，栈的顺序存储结构中变量记录的是栈顶的位置。 进栈操作 123456789//插入元素e为新的栈顶元素Status push(SqStack *S,SElemType e){ if (S-&gt;top=MAXSIZE-1) return ERROE; S-&gt;top++; S-&gt;data[S-&gt;top]=e; return OK;} 出栈操作 123456789//删除s的栈顶元素，用e返回其值Status Pop(SqStack *S,SElemType *e){ if(S-&gt;top==-1) return ERROE; *e=S-&gt;data[S-&gt;top]; S-&gt;top--; return OK;} 进栈出栈操作同线性表相关操作类似，先判断异常，再进行操作。 双栈共享空间 双栈共享空间结构 123456typedef struct { SElemType data[MAXSIZE]; int top1;//栈一以数组0作为栈底 int top2;//栈二以数组n-1作为栈底}SqDoubleStack; 双栈共享空间插入元素 1234567891011121314151617//插入元素e为新的栈顶元素Status Push(SqDoubleStack *S,SElemType e,int stackNumber){ if(S-&gt;top1+1==S-&gt;top2) return ERROE; if(stackNumber==1) { S-&gt;top1++; S-&gt;data[S-&gt;top1]=e; } else if(stackNumber==2) { S-&gt;top2--; S-&gt;data[S-&gt;top2]==e; } return OK;} 双栈共享空间弹出元素 1234567891011121314151617181920//删除S栈顶的元素，用e返回其值Status Pop(SqDoubleStack *S,SElemType *e ,int stackNumber){ if(stackNumber==1) { if(S-&gt;top1==-1) return ERROE; *e=S-&gt;data[S-&gt;top1]; S-&gt;top1--; return OK; } else if (stackNumber==2) { if (S-&gt;top2==MAXSIZE) return ERROE; *e=S-&gt;data[S-&gt;top2]; S-&gt;top2--; return OK; }} 使用两栈共享空间的数据结构，通常都是当两栈的空间需求有相反关系。否则两栈都不停的增长，很快就会栈满溢出了。 栈的链式存储结构 栈的链式存储结构 12345678910typedef struct StackNode{ SElemType data; struct StackNode *next;}StackNode,*LinkStackPrt;typedef struct LinkStack{ LinkStackPrt top; int count;}LinkStack; 栈的链式存储结构包含两个结构体，第一个结构体作为栈中数据元素存储结点，只负责存储数据元素，第二个结构体作为指向栈顶元素的头指针结构体，负责记录栈顶元素以及元素个数。 栈的链式存储结构与线性表的链式存储结构区别在于，线性表的链式存储结构中，头结点的存在是为了让第一个数据元素与其他数据元素的插入，删除等其他操作相同。栈的链式存储结构中，因为只对栈顶元素操作，所以舍弃了头结点的概念。我们另起一个结构体，用于头指针top并指向我们的数据元素，记录数据元素个数。 进栈操作 12345678910//插入元素e为新的栈顶元素Status Push(LinkStack *S,SElemType e){ LinkStackPrt s =(LinkStackPrt)malloc(sizeof(StackNode)); s-&gt;data=e; s-&gt;next=S-&gt;top; S-&gt;top=s; S-&gt;count++; return OK;} 出栈操作 12345678910111213//删除S的栈顶元素，用e返回其值Status Pop(LinkStack *S,SElemType *e){ LinkStackPrt p; if(S-&gt;top==NULL) return ERROE; *e=S-&gt;top-&gt;data; p=S-&gt;top; S-&gt;top=S-&gt;top-&gt;next; free(p); S-&gt;count--; return OK;} 栈的两种存储结构总结从栈的两种存储结构的操作可以看出，两者操作的时间复杂度均为O(1),所以两种存储结构的区别不在时间复杂度上，而在空间复杂度上，栈的顺序存储结构的缺点即为数组的缺点，对于未知元素范围，数组定义太大可能会造成空间浪费，定义太小可能会造成数据溢出。栈的链式存储结构缺点在于栈的每个数据结点都拥有一个指针域，这样也增加了内存的开销。 所以如果栈的使用过程中元素变化不可预料，有时很小，有时非常大，那么最好是用链栈，反之，如果它的变化范围在可控范围内，建议使用顺序栈会更好一些。 栈的应用递归栈的一个重要应用就递归，那么什么是递归呢，我们把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称作递归函数。 斐波那契递归数列 12345678910111213//斐波那契的递归函数int Fbi(int i){ if(i&lt;2) return i==0?0:1; return Fbi(i-1)+Fbi(i-2);}int main(){ for(int i=0;i&lt;40;i++) printf(&quot;%d&quot;,Fbi(i)); return 0;} 四则运算表达式求值后缀表示法，逆波兰表示法，对于9+（3-1）3+10/2，如果要用后缀表示法应该是什么样子：“9 3 1-3+10 2/+”，这样的表达式称为后缀表达式，叫后缀的原因在于所有的符号都是在要运算的数字后面出现。 后缀表达式运算规则：从左到右遍历表达式的每个数字和符号，遇到是数字就进栈，遇到是符号，就将处于栈顶的两个数字出栈，进行运算，运算结果进栈。 中缀表达式转后缀表达式规则：从左到右遍历中缀的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级低于栈顶符号（乘除优先加减）则栈顶元素依次出栈并输出，并将当前符号进栈，一直输出到最终后缀表达式为止。 要想让计算机具有处理我们通常的标准表达式的能力，最重要的就是两步： 将中缀表达式转化为后缀表达式（栈用来进出运算的符号） 将后缀表达式进行运算得出结果（栈用来进出运算的数字） 队列队列的定义：​ 队列是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。队列是一种先进先出（First In First Out）的线性表，简称FIFQ。允许插入的一端称为队尾，允许删除的一端称为对头。 循环队列​ 队列顺序存储中，我们定义front 和rear两个指针，front指针指向队列的对头元素，rear指向队尾元素后面的第一个闲置空间，当front等于rear时，此队列为空。 ​ 如果数组后面的空间已经满了，但是前面还有空间，我们把这种现象叫做“假溢出”。我们解决假溢出的办法就是后面满了。就再从头开始，也就是头尾相接的循环。我们把队列这种头尾相接的顺序存储结构称为循环队列。 ​ 此时问题又来了，我们刚才说，队列为空时，front等于rear，现在队列满了，front还是等于rear。那么如何判断此时的队列是空还是满呢？ ​ 我们可以保留一个元素空间。也就是说每当队列满时，数组中还有一个空闲单元。若队列最大尺寸为QueueSize，那么 队列满的条件是：(rear+1)%QueueSize==front。 计算队列长度的公式为：（rear-front+QueueSize)%QueueSize 循环队列的顺序存储结构 123456typedef struct { QElemType data[MAXSIZE]; int front; int rear;}SqQueue; 循环队列初始化操作 123456Status InitQueue(SqQueue *Q){ Q-&gt;front=0; Q-&gt;rear=0; return OK;} 求循环队列长度 1234int QueueLength(SqQueue Q){ return((Q.rear-Q.front+MAXSIZE)%MAXSIZE);} 循环队列入队操作 12345678Status EnQueue (SqQueue *Q,QElemType e){ if((Q-&gt;rear+1)%MAXSIZE==Q-&gt;front) return ERROE; Q-&gt;data[Q-&gt;rear]=e; Q-&gt;rear=(Q-&gt;rear+1)%MAXSIZE; return OK;} 在这一步操作中，Q-&gt;rear=(Q-&gt;rear+1)%MAXSIZE;这条语句在判断rear是不是数列最后一个元素的同时，还将rear指向下一个位置。这一个语句是真的妙。替代了一句if-else。 循环队列出队操作 123456789//删除Q中对头元素，用e返回其值Status DeQueue(SqQueue *Q,QElemType *e){ if(Q-&gt;front==Q-&gt;rear) return ERROE; *e=Q-&gt;data[Q-&gt;front]; Q-&gt;front=(Q-&gt;front+1)%MAXSIZE; return OK;} 队列的链式存储结构队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，我们把它简称为链队列。为了在操作上方便，我们将队头指针指向链队列的头结点，而队尾指针指向终端结点。 链队列的结构 123456789typedef struct QNode{ QElemType data; struct QNode *next;}Qnode,*QueuePtr;typedef struct { QueuePtr front,rear;}LinkQueue; 链队列的入队操作 123456789Status EnQueue (LinkQueue *Q,QElemType e){ QueuePtr s=(QueuePtr)malloc(sizeof(QNode)); s-&gt;data=e; s-&gt;next=NULL; Q-&gt;rear-&gt;next=s; Q-&gt;rear=s; return OK;} 队列的出队操作 1234567891011121314//删除Q的队头元素，用e返回其值Status DeQueue(LinkQueue *Q,QElemType *e){ QueuePtr q; if (Q-&gt;rear==Q-&gt;front) return ERROE; q=Q-&gt;front-&gt;next; *e=q-&gt;data; Q-&gt;front-&gt;next=q-&gt;next; if(Q-&gt;rear==q) Q-&gt;rear=Q-&gt;front; free(q); return OK;} 此操作注意两点： 链队列的队头指针指向的不是第一个数据元素，而是和单链表一样，指向的是头结点。在出队操作时，要注意跳过头结点。 链队列在出队操作时，不光要考虑队列是否为空，还要考虑出队元素是否为队列中的最后一个，如果是，执行 Q-&gt;rear=Q-&gt;front;语句，将队尾指针提前指向头结点，防止将最后一个元素释放后，队尾指针指向NULL。 队列的两种存储结构总结从队列的两种存储结构的操作可以看出，两者操作的时间复杂度均为O(1),所以两种存储结构的区别不在时间复杂度上，而在空间复杂度上，队列的顺序循环存储结构的缺点即为数组的缺点，对于未知元素范围，数组定义太大可能会造成空间浪费，定义太小可能会造成数据溢出。队列的链式存储结构缺点在于栈的每个数据结点都拥有一个指针域，这样也增加了内存的开销，但是这也可以接受，所以在空间上，链队列更加灵活。 总的来说，在可以确定队列的最大长度的情况下，建议使用循环队列，如果无法预估队列长度，则用链队列。 栈和队列的总结回顾栈和队列是两种特殊的线性表，只不过栈和队列的进出限制不同，栈和循环队列因为他们特殊的操作要求，所以不管是顺序存储结构还是链式存储结构，它们操作 的时间复杂度都为O(1)。但是在空间存储上，链式存储结构更灵活，更省心，尽管链式存储结构在内存上会有一些其他的开销，但也可以接受。所以综合来说，未来关于队列和栈的运用上，优先考虑链式存储结构。 第五章 串串不同于线性表和栈和队列等数据结构，串的数据长度是有限序列 串的定义串是由零个或多个字符组成的有限序列，又名叫字符串。串中的字符数目n称为串的长度。零个字符的串称为空串。“有限序列”的意思是长度n是一个有限的数值，序列说明串的相邻字符之间具有前驱和后继的关系。 空格串：只包含空格的串，其有内容有长度。 子串与主串：串中任意个数的连续字符组成的子序列称为该串的子串，相应的包含子串的串称为主串。 子串在主串中的位置就是子串的第一个字符在主串中的序号。 串的比较给定两个串，例如s=“hap”，t=“happy”，因为s和t前三个字符相同，但是t比s多两个字母，所以s&lt;t。 给定两个串，s=“happen”,t=”happy”,因为两串前四个字母都相同，但是两串第五个字母不同e的ascII码为101，y的ascII码为121，显然e&lt;y,所以s&lt;t。 总之就是给两个串，上来就遍历比较，不一样就可以分大小。 朴素的模式匹配算法子串的定位操作通常称做串的模式匹配 KMP模式匹配算法KMP算法，是一种模式匹配算法，它可以大大避免重复遍历的情况。 书上的讲解过于抽象，以下视频是我在网上找到的讲的最好的视频。生动并且清晰。 字符串匹配-KMP算法1(模式匹配) KMP算法2-next数组(字符串匹配) 第六章 树树的定义树是n个结点的有限集。n=0时称为空树。在任意一颗非空树中： 有且仅有一个特定的称为根的结点； 当n&gt;1时，其余结点可以分为m个互不相交的有限集。其中每一个集合本身又是一棵树，并称为根的子树。 对于树的定义还需强调两点： n&gt;0时根结点是唯一的，不可能存在多个根结点。 m&gt;0时，子树的个数没有限制，但他们一定是互不相交的。 结点分类： 结点拥有的子树数称为结点的度。度为0的结点称为叶结点或终端结点；度不为0的结点称为非终端结点或分支结点。除根结点之外，分支结点也称为内部结点。树的度时树内部各结点的度的最大值。 ![屏幕截图 2021-01-29 220716](https://gitee.com/xu-ha-ha456/blogimage/raw/master/img/屏幕截图 2021-01-29 220716.png) 结点间的关系： 结点的子树的根称为该结点的孩子，相应的，该结点称为孩子的双亲。同一个双亲的孩子之间互称兄弟。 树的其他相关概念： 结点的层次从根开始定义起，根为第一层，根的孩子为第二层。树中结点的最大层次称为树的深度或高度。 如果将树中结点的各子树看成从左至右是有次序的，不能互换，则称该树为有序树，否则称为无序树。 森林是m棵互不相交的树的集合。 树的结构特征： 线性结构：第一个数据元素无前驱，最后一个数据元素无后继，中间的数据元素一个前驱，一个后继。 树形结构：根结点：无双亲，唯一的。叶结点：无孩子，可以多个。中间结点：只有一个双亲，但是有多个孩子。 树的存储结构 双亲表示法 双亲表示法有点类似于静态链表的结构。我们在每个结点中，附设一个指示器指示其双亲结点到链表中的位置。结点中分为data数据域和parent指针域，数据域用于存储数据元素，指针域用来指示该结点双亲的位置。 双亲表示法结点结构定义代码 123456789101112#define MAXSIZE 100typedef int TElemType;typedef struct PTNode{ TElemType data; int parent;}PTNode;typedef struct { PTNode nodes[MAXSIZE]; int r,n;//根的位置和结点数}PTree; 因为根结点没有双亲，所以我们规定根结点的指针域设置为-1。 存储结构的设计是一个非常灵活的过程。一个存储结构设计的是否合理，取决于基于该存储结构的运算是否合适，是否方便，时间复杂度好不好等。 孩子表示法 把每个结点的孩子结点排列起来，以单链表作为存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。然后n个头指针又组成一个线性表，采用顺序存储结构，存放进一个以为数组中。 结构定义代码 123456789101112131415typedef struct CTNode{ int child; struct CTNode *next;}*ChildPtr;typedef struct{ TElemType data; ChildPtr firstchild;}CTBox;typedef struct { CTBox nodes[MAXSIZE]; int r,n;}CTree; 第一个结构体，作为单链表结构child存储孩子在数组中的编号。 第二个结构体，作为树中的结点，存储数据元素以及孩子链表的头指针。 第三个结构体，作为树的结构，nodes存储树的每一个结点，r表示树的头结点，n表示这棵树拥有的结点个数。 孩子兄弟表示法 任何一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的兄弟。 12345typedef struct CSNode { TElemType data; struct CSNode *firstchild,*rightsib;}CSNode,*CSTree; 二叉树的定义二叉树是n个结点的有限集合，该集合或者为空集，或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。 二叉树特点： 每个结点最多有两棵子树。所以二叉树中不存在度大于2的结点。 左子树和右子树是有顺序的，次序不能颠倒。 即使树中某结点只有一颗子树，也要区分他是左子树还是右子树。 特殊二叉树： 1.斜树： &emsp;&emsp;所有结点都只有左子树的二叉树叫做左斜树。所有结点都只有右子树的二叉树叫做右斜树。这两者统称为斜树。 &emsp;&emsp;其实线性表的结构就可以理解为是树的一种及其特殊的表现形式。 2.满二叉树： &emsp;&emsp;在一棵二叉树中，如果所有的分支系欸但都存在左子树和右子树，并且所有叶子都在同一层，这样的二叉树称为满二叉树。 3.完全二叉树： &emsp;&emsp;满二叉树缺少最后一排靠右位置连续的叶子结点。 二叉树的存储结构因为二叉树的结构限制，以及顺序存储结构的弊端，所以顺序存储结构一般只用于完全二叉树。 二叉链表 123456//二叉树的二叉链表结点结构定义typedef struct BiTNode{ TElemType data; struct BiTNode *lchild,*rchild;}BiTNode,*BiTree; 因为二叉树只有两个孩子，所以在结构中设置左孩子和右孩子 *BiTree作为二叉树的头指针，指向二叉树的根结点。 二叉树的存储结构可以随意更改，如果有需要，还可以加入指向双亲的指针。 遍历二叉树二叉树的遍历是指从根结点出发，按照某种次序依次访问二叉树中的所有结点，使得每个结点被访问一次且仅被访问一次。 前序遍历 &emsp;&emsp;规则是若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。 123456789//二叉树的前序遍历递归算法void PreOrderTraverse(BiTree T){ if (T=NULL) return; printf(&quot;%c&quot;,T-&gt;data); PreOrderTraverse(T-&gt;lchild); PreOrderTraverse(T-&gt;rchild);} 前序遍历采用了经典的递归遍历方式，对比于循环，这是一种很灵活的算法。 中序遍历 &emsp;&emsp;规则是若树为空，则空操作返回，否则从根结点开始（注意并不是先访问根结点），中序遍历根节点的左子树，然后是访问根结点，最后中序遍历右子树。 123456789//二叉树中序遍历算法void InOrderTraverse(BiTree T){ if (T=NULL) return; InOrderTraverse(T-&gt;lchild); printf(&quot;%c&quot;,T-&gt;data); InOrderTraverse(T-&gt;rchild);} 中序遍历法相对于前序遍历法，只是代码的运行顺序发生了改变。 后序遍历 &emsp;&emsp;规则是若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点。 123456789//二叉树的后序遍历递归算法void PostOrderTraverse(BiTree T){ if(T==NULL) return ; PostOrderTraverse(T-&gt;lchild); PostOrderTraverse(T-&gt;rchild); printf(&quot;%c&quot;,T-&gt;data);} 后序遍历就是先遍历树，再打印数据元素。三者不同在于打印元素的位置不同，进而导致遍历的方式不同。 层序遍历 &emsp;&emsp;规则是若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。 二叉树的建立1234567891011121314151617//二叉树的建立void CreateBiTree(BiTree *T){ TElemType ch; scanf(&quot;%C&quot;,&amp;ch); if (ch=='#') *T=NULL; else { *T=(BiTree)malloc(sizeof(BiTNode)); if (!*T) exit (OVERFLOW); (*T)-&gt;data=ch; CreateBiTree(&amp;(*T)-&gt;lchild); CreateBiTree(&amp;(*T)-&gt;rchild); }} 建立二叉树，也用到了递归的原理，在这里我不一一解释了，感兴趣的可以上网上搜索一下二叉树的建立方法。 搜索二叉树我们把二叉树中指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树。 具体结构看书。 结尾语树这一章学习完了，总体来说，树的知识过于庞大，我第一遍学习还没消化得了。还得多学几遍。","link":"/2021/01/13/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0%E3%80%91%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"【金融理财】之《小狗钱钱》","text":"“欧洲巴菲特”撰写的理财启蒙图书。 &emsp;&emsp;《小狗钱钱》这本投资理财的入门读物，我从被推荐这本书，到阅读它，中间经历了差不多一年的时间。去年第一次读完之后有一种相见恨晚的感觉，最近放假在家，又将这本书重新读了一遍，产生了不少的感悟，故写下这篇读书笔记。 &emsp;&emsp;这本书开篇有一句话深深的吸引了我，真正的勇气是在感到恐惧的时候，你依然在往前走。看到这句话时，我想起了鲁迅先生创作的《记念刘和珍君》其中的一句话“真正的勇士敢于直面惨淡的人生，敢于正视淋漓的鲜血”。正所谓，成功路上的艰难并不是苦，也不是孤独，而是屡遭挫折之后还能不改初心的继续奔跑。任何阻挡你前行脚步的力量，从来就不是任何客观因素，而是你自己的勇气。 &emsp;&emsp;书籍开篇还提出一个观点，认为我们必须忍受拮据的生活，甚至认为这样才是高尚的——这种想法是人类犯下的最重大的错误之一。的确，从小到大我被灌输的一种思想观念就是，勤俭节约，艰苦奋斗。我记得在我上小学的时候，朴素生活的企业家都会被大肆宣传，供大家学习。后来在我的价值观念逐渐成型后，我就经常在想，如果我们始终保持拮据的生活，那我们大部分人奋斗终生的意义在哪，国内的内循环经济还能靠什么运转？后来我明白了，我们有权力追求任何我们想要的生活，不管奢靡还是拮据，只要不浪费就好。 &emsp;&emsp;个人经历是很难效仿的，但最基本的真理却完全可以复制。这句话不光可以应用在本书的后续阅读中，还应贯彻在生活中，《小狗钱钱》这本书是写给孩子的理财书籍，从头到尾都是以童话故事的形式展现给大家。我早已过了读童话的年纪，所以阅读这本书的时候，我没有过分的将我的注意力放在故事上，而是跟着这本书学习更多的投资理财知识。 &emsp;&emsp;忽视是一种认输。对问题视而不见，就是一种认输，如果我们对我们现有的理财方式视而不见，也就证明我们现有的理财方式没有达到我们想要的标准，我们应尽快调整，达到最好的标准。 &emsp;&emsp;钱钱教给吉娅理财的第一步就使让他写下十个我想变得富有的原因，并且告诉吉娅，从今往后，做任何事情，不是试试看，而是去切实行动，如果你只是抱着试试看的心态，那么你只会以失败告终，你会一事无成。然后钱钱要求吉娅在十个愿望中挑选三个认为最重要的愿望。并且钱钱告诉吉娅这一步第一，制作一个梦想相册，第二件事，每天看几遍相册，然后想象你已经实现梦想的场景，将自己大部分精力放在自己喜欢的事情上，而不是不喜欢的事情上。。第三件事，准备一个梦想储蓄罐。钱钱教给吉娅的这几点，高度契合了《秘密》这本书中的吸引力法则。一本是理财书籍，一本是哲学书籍，两本领域完全不同的书籍，能有这样的达成共识的观点，足以为我们读者在侧面证明吸引力法则以及钱钱教给吉娅理财规则的真实性，其实规律就像电，你不用知道电的运行原理，你会用电就行了，生活中有好多规律我们可能不理解，我们只需要理解学习并实践就可以了。我记得去年和一位老师见面聊天，他是某个行业的大牛，他在那次交谈中告诉我，未来身处行业中，对行业中方方面面的事情，看不懂时找老师跟着学，看得懂时拼命学。 &emsp;&emsp;你是否能挣到钱，最关键的并不是你有没有好点子，也不是你有多聪明，而是你的自信程度。如何树立自信？撰写自己的“成功日记”。这是钱钱教给吉娅关于理财的第二件事情，信心对我们的生活弥足珍贵。为了树立信息，我们可以像吉娅一样，撰写我们个人的成功日记，把我们生活中值得高兴并给予我们信心的事情记录下来。在未来遇到问题时只要翻一翻成功日记，你就会从过去的事物中找到证据，相信自己未来也有能力完成任何事情。 &emsp;&emsp;为别人解决一个难题，那么你就能赚到许多钱；把精力集中在你知道的、能做的和拥有的东西上。赚钱好像就是这样， 生活中方方面面透露着赚钱的机会，但是一个人并不能把所有的钱都赚了。将自己有限的精力放在已知的事情上，并持续发光发热。 &emsp;&emsp;无论在什么时候都不能把希望寄托在一份工作上，它持续的时间不会像你设想的那么长，所以你要立即寻找另一份替代的工作。 在这个副业刚需的年代，有两份以上收入越来越重要了，就像去年的疫情，持续的防疫工作，导致大批人群失去工作收入，所以趁年轻我们多增加个人资产，多扩展收入来源。 &emsp;&emsp;情况顺利的时候，人人都能挣到钱，只有在逆境中，一切才能见分晓。 &emsp;&emsp;钱钱教给吉娅的第三件事，就是当你决定做一件事情的时候，你必须在72小时之内完成，否则你很可能永远不会再做了。付出实践的关键：72小时，钱钱教给吉娅，任何时候想法到实践的最佳时机是72小时以内，72小时之内不付出行动，我们可能永远也不会再行动。 &emsp;&emsp;如何解决负债问题，这是一个棘手又重要的事情。解决负债问题，第一，欠债的人应当毁掉所有的信用卡。第二，应当尽可能少的偿还贷款。第三，将扣除生活费后剩下的钱的一半存起来，剩下的一半用于支付消费贷款。最好根本不申请消费贷款。第四，消费时时刻提醒自己，这真的有必要吗？好多人不理解第二条为什么要这样做，这样做最终偿还的利息不就更多吗。这其实要涉及钱钱教给吉娅的另一件事情：资产要合理分配，将自己的收入分成三份，一份用于培养大鹅，一份用于为梦想储蓄，一份用于日常开销及零花。没月尽可能少的长换贷款，也就尽可能减少每月的日常开支，将收入剩下的钱用于培养属于自己的大鹅，以及为我们梦想板上的梦想储蓄，这样做可以让我们在还清负债后，不至于资产清零，以及在遇到特殊情况时，不至于再产生负债。 &emsp;&emsp;尝试做自己喜欢的事情而挣到钱。把某些自己不喜欢做，而又不擅长做的事情交给别人就行了。这一句话几乎将赚钱的本质交代清楚了，每个人的赚钱方式，工作内容都不尽相同，选好自己的方向，将自己喜欢的事情做到极致，懂得将自己有限的精力放在你自己认为有价值的事情上。 &emsp;&emsp;幸运其实只是充分准备加上努力工作的结果。正所谓，越努力，越幸运。 &emsp;&emsp;没有人能强迫你做你不愿意做的事情，只有你自己才能强迫自己去做。 &emsp;&emsp;决定一件东西价值多少的唯一因素就是，你愿意为它支付多少钱。对于这句话，其实我思考的角度不是商品，而是我个人，我在读到这句话的时候，会以第三人称审视我自己。作为一名消费者或者资本家，愿意用多少钱购买我创造的商品，或者我提供的价值。 &emsp;&emsp;以下就是在书籍最后，金太太提供的基金选购指南。 &emsp;&emsp;挑选基金的注意事项： 1、基金应该至少有10年历史。假如它在长时间内一直有丰厚的利润，那我们可以认为，未来它也会运作良好。 2、应该选择大型的跨国股票基金。这种基金在世界各地购买股票，以此分散风险，所以十分安全。 3、对基金的走势图进行比较。我们应该观察在过去10年间哪些基金的年终利润最好。","link":"/2021/01/12/%E3%80%90%E9%87%91%E8%9E%8D%E7%90%86%E8%B4%A2%E3%80%91%E4%B9%8B%E3%80%8A%E5%B0%8F%E7%8B%97%E9%92%B1%E9%92%B1%E3%80%8B/"},{"title":"2020-2021学年冬季专项辅导之“起跑计划”","text":"Hey, password is required here. 0c82b86e5647251762290254cb1ac24020f173fb1e162319b4b4d797b7d3e2fee75dd4b82a935fb78b310fd1242829eaa35fffb7f16b22cf1c319078272141d05f886b8071bcf871942f376e479b5c1d5e310776eca20b396cf8eea1e7b91f4416b82c4335d228b9945fa0327c880aeceedc0bf26b7e136782384c1120a96156687643169f2cb68a09f2d900aea43b4dd326b050d34a185acc66ad6d1cd08ca0","link":"/2021/01/16/2020-2021%E5%AD%A6%E5%B9%B4%E5%86%AC%E5%AD%A3%E4%B8%93%E9%A1%B9%E8%BE%85%E5%AF%BC%E4%B9%8B%E2%80%9C%E8%B5%B7%E8%B7%91%E8%AE%A1%E5%88%92%E2%80%9D/"},{"title":"【人生哲学】之《秘密The Secret》","text":"这个秘密已经流传千百年，曾被埋藏，令人觊觎，更被禁止，遭人盗窃，甚至被天价索购。 ​ 去年八月份，和一位许久未见的朋友见了一面，在聊天的过程中，他向我推荐了这本书。我当时还没有阅读这本书，而是看了这本书的同名电影《The Secret》，当时这部影片给我的感觉很震撼，影片给了我充足的信心和勇气，让我随意去畅想未来。影片中的观点我也经常分享给我身边的朋友和家人。时隔半年，这次放假回家，无意中在父亲的床头发现了这本书，据父亲说，这是他的一位朋友特意买来送给他的，赠送前还特意叮嘱，“我这辈子没看过几本好书，这本书写的相当好，送你一本你好好看看。”我们父子二人就这样冥冥之中都被朋友推荐看了这本书。今天，我将父亲的这本纸质版《秘密》借来，从头到尾好好的翻一了一遍，并写下了今天的这篇笔记。 ​ 这本书开篇为 上行，下效。存乎中，形于外。 书中描述这句话来源于3000年前的一块翡翠石板，这句话的意思大概就是，上面传达命令，下面执行命令。心里所想的，都会以实物表现在外界。这本书叫做《秘密》，全书的内容都在描写这个秘密——吸引力法则，吸引力法则描述，我们现在生活中一切事物，都来源于曾经我们的思想，思想就像一块磁铁，吸引所有你想吸引的东西，你目前的生活就是你过去思想的映像。这样描述比较难理解，我们可以举个例子，比如你现在想要一栋大房子，你可以想象你现在就住在这栋大房子里，并且你愿意相信，你早晚都会拥有这栋房子。你持续的给自己大房子这样的暗示，生活就会悄悄的替你实现这个愿望，这就是吸引力法则。这个法则可以理解为八个字，念念不忘，必有回响。并且书中一直在强调，思想对你生命发展的重要性，如果想改变生命中的任何事情，就先改变你的思想。你的生命发展会根据你的思想做调整。 ​ 但是生活中频繁出现不如意的场景，这也是我们思想得到的回应吗？其实这是因为对“不想要的”想的比“想要的”多，吸引力法则就是自然法则，它是客观的，眼中没有好的、坏的分别。它只是接收你的思想，然后以生命经验的形式，把这些思想回应给你。吸引力法则只是给你自己所想的东西罢了。正因如此，吸引力法则告诉我们面对问题多想好的，积极乐观的方面。我们每天有大把的时间用于思考，这些思想会化作力量映像到我们的生活中，所以我们在思考的时候多想一些好的事情吧。 ​ 并且书中在说明吸引力法则的同时，还凸显了一个重要观点，你的生命掌握在你手中。不论你现在身在何处、不论你生命中发生过什么事，你都可以开始有意识地选择你的思想，进而改变你的生命。根本没有所谓的“绝境”，你生命的每个境况，都是能改变的！你当下的思想正在创造你的未来。你最常想的或最常把焦点放在上头的，将会出现在你的生命中，成为你的人生。 ​ 接下来这本书开始教我们如何运用吸引力法则，在前面我们明白，好的思想控制我们的生活向好的方向发展，糟糕的思想控制我们的生活向糟糕的方向发展，我们不可能操纵我们的思想，但是我们可以通过感觉来判断我们的思想是否是我们需要的，因为感觉是由思想所引发的。不好的感觉和好的思想，是不可能同时存在的。不好的思想伴随着愤怒，沮丧的感觉，好的思想伴随着愉快，感激的感觉，感觉就是思想的反馈机制。并且我们生活中经常出现的一连串出错的经历，都是思想的连锁反应，所以当我们感到沮丧，愤怒的时候，我们需要一瞬间改变它，时刻保持自身感觉良好。读到这里，你应该拿出纸和笔，将可以轻易改变你的感觉的事物，列出来，作为你的“秘密转移物”。笑，能引来喜悦，释放消极心态，改变消极的思想。 作者还给出了吸引力法则的实操方法，通过三个步骤，创造你所想要的任何事物。 第一，要求 把你真正想要的东西写在纸上，有要求就会有回应 如果我想要减肥，我就要找一张完美身材的照片，时常看着这些照片。 第二，相信 相信你所要求的东西是你的了，你要有不动摇的信心相信，在你要求的那一刻，你所要求的东西就已经是你的了 在这里我想到了高中时一位老师所说过的一句话，要想得到，必先成为。在这个阶段，要时刻相信并想象自己已经拥有了完美的身材，找到拥有完美身材过后的感觉。 第三步 接受 找到怎样才能帮助你产生“我现在就已经拥有它”的感觉。并将这种感觉坚持下去。 忘记当前的体重，把焦点全部都放在完美身材上，时刻接受并体会完美身材的感受。 作者给出了实操的方法，到这里读者最关心的还是，要求的实现要多久？书中所说，所有的要求在你提出的同时，生活就已经满足了你的这个要求，但是何时会出现在你的身边，这就要看你对这个要求的感觉，感觉越强烈，要求实现的时间就越短。书中建议每天结束时，在你睡觉之前，去想想一整天所发生的事。如果有任何的时刻或事件不是你想要的样子，那就改用能使你满意的方式，在心中“回放”一次。当你完全依照你所要的样子，在心中重新创造这些事件，就等于消除了当天的频率，并为明天发出新的讯号和频率。你已经有意地为你的未来创造出新的生命画面。改变生命画面，是永远不嫌晚的。 ​ 书中还为我们提供了关于吸引力法则，两个强有力的方法，感恩是改变人生强有力的方法其一，书中要求我们要长怀一颗感恩的心，感恩的心这不是一句空谈，这是我们主动改变我们感觉，进而改变我们思想的一种方式，我们要行动起来。视觉化是强有力的方法其二，将我们的愿望可视化，则吸引力法则体现的就更明显。并且书中还提到，如果你心中想出来的景象是静止的画面，那么要保持它就会很困难，因此，为你的愿望景象多创造一些动态的动作。 ​ 到此，书里面的核心内容也就结束了，从头到尾阅读了一遍《秘密》这本书，发现这本书在处理生活问题方面，给了我很大的启发，同时我也感觉《秘密》这本书写的十分枯燥，以访谈的形式编写书籍内容，与其说是一本书，我觉得更像是一本访谈纪录片的台词本。我个人不喜欢这种书籍风格，但是为了阅读书中的观点，我也硬着头皮读完了。书中的吸引力法则是一种唯心主义的观点，这种观点就像作者所说的，许多人不知道吸引力法则的原理，但是却应用它在生活的方方面面，就像万有引力一样常见。就像我在上文提到的，我的高中老师所说的，要想的到，必先成为。以及在《小狗钱钱》中，钱钱对吉娅说，如果你将你的梦想制作成梦想版，则它们一定会实现。吉娅听话照做制作了梦想版。吉娅她那些在当时看似遥不可及的梦想，也一一实现了。这也是吸引力法则的另一个有力的证明。这其实也符合我们中国老话所说的：念念不忘，必有回响。","link":"/2021/01/18/%E3%80%90%E4%BA%BA%E7%94%9F%E5%93%B2%E5%AD%A6%E3%80%91%E3%80%8A%E7%A7%98%E5%AF%86%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"title":"博客相关问题一揽子记录","text":"1.icarus主题打开慢 2.如何设置ICP备案代码 icarus主题打开慢换了icarus主题后，没有科学上网的情况下打开非常慢，基本打开不了。后来通过查看浏览器请求，发现是一些字体、css文件请求失败的原因： 找到_config.icarus.yml，在最后的providers，修改：全部修改为loli 1234567providers: # Name or URL template of the JavaScript and/or stylesheet CDN provider cdn: loli # Name or URL template of the webfont CDN provider fontcdn: loli # Name or URL of the fontawesome icon font CDN provider iconcdn: loli 找到themes/icarus/layout/common/head.jsx 注释掉： default: fontcdn(‘Ubuntu:wght@400;600&amp;family=Source+Code+Pro’, ‘css2’), 1234const fontCssUrl = { // default: fontcdn('Ubuntu:wght@400;600&amp;family=Source+Code+Pro', 'css2'), cyberpunk: fontcdn('Oxanium:wght@300;400;600&amp;family=Roboto+Mono', 'css2')}; ICP备案显示博客之前一直部署在github服务器上，github部署虽然免费，但是在国内访问博客速度奇慢。关于访问太慢的问题，想过两套方案解决。一是配合国内gitee服务器实现双部署，访问速度提高了，但是gitee服务器不支持自动更新，每次部署完都要手动更新。二是直接购买云服务器，将网站部署在云服务器上，访问速度提上来了，但是云服务器每年的租金又是一笔开销。 在今年双十二期间，腾讯云活动服务器一年只要99元，比学生认证购买还要便宜，直接下单，网站整体搬迁到云服务器上。国内的法律规定，把网站部署到云服务器上需要在省网信部备案，经过几天的等待，备案审核终于通过了，现在只要把备案号添加到网站底部，网站就可以正常投放到互联网上了。 当我准备把备案号加在网站底部时发现，icarus这个主题竟然没有添加备案号的接口，没办法，只能上网找资料自己修改源文件，把这个接口写上了。 一、寻找相关文件在themes/icarus/layout/common路径下找到footer.jsx文件 二、修改源代码123456789101112 {footerLogo} &lt;/a&gt;//找到这个位置，并把以下源代码插入到这个位置 &lt;p class=&quot;is-size-7&quot;&gt; &lt;span dangerouslySetInnerHTML={{ __html: `&amp;copy; ${siteYear} ${author || siteTitle}` }}&gt;&lt;/span&gt; &amp;nbsp;&amp;nbsp;Powered by &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;&amp;nbsp;&amp;&amp;nbsp; &lt;a href=&quot;https://github.com/ppoffice/hexo-theme-icarus&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Icarus&lt;/a&gt; {showVisitorCounter ? &lt;br /&gt; : null} {showVisitorCounter ? &lt;span id=&quot;busuanzi_container_site_uv&quot; dangerouslySetInnerHTML={{ __html: visitorCounterTitle }}&gt;&lt;/span&gt; : null} &lt;/p&gt; 123456//被插入源代码&lt;p class=&quot;size-small&quot;&gt; &lt;a href=&quot;http://www.beian.miit.gov.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;冀ICP备XXXXXXX&lt;/a&gt; &lt;span class=&quot;post-meta-divider&quot;&gt;&amp;nbsp;|&amp;nbsp;&lt;/span&gt; &lt;a target=&quot;_blank&quot; href=&quot;http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=XXXXXXXXXX&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;你的网站地址/img/beian.png&quot; /&gt; 冀公网安备 XXXXXXXXX号&lt;/a&gt; &lt;/p&gt; 三、注意事项1.源代码打开用vscode ，不要用其他编辑器，因为vscode编辑器文本默认保存格式为UFT-8，其他编译器默认文本保存格式若不是UFT-8，在网站上会出现乱码显示 2.将源代码调整合适","link":"/2020/12/16/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E4%B8%80%E6%8F%BD%E5%AD%90%E8%AE%B0%E5%BD%95/"},{"title":"《小猪佩奇》听力笔记","text":"屠鸭第一步，先从英语听力开始，听说读写，一步一步完成。 小猪佩奇听力训练分为三部分 预习：每天睡前30分钟。盲听三遍，看听三遍 练习：清晨练习一小时。练习听：语块化，回音法，意会练习。练习说：动画中每一句话复述出来。 复习：下午零散的时间复习30分钟左右。利用anki进行复习。采用画面复习法。 学习要聚而强，复习要散而缓 第一季第二集 Mr Dinusaur is losti beg you pardon 对不起你说什么 tuck up 盖好被子 第七集 mummy pig at workmend&emsp;&emsp;修理 第八集 piggy in the middleget stuck 卡住 第十一集 hiccpusspoil 毁坏 rub 按摩；轻挠 tongue 舌头 roughly 粗暴 beaker 杯 第十五集 picnicpicnic blanket 野餐布 lemonade 柠檬水 forget 忘记 strawberry 草莓 home-made 自制 nap 打盹 pond 池塘 you lot again 又是你们啊 certainly&emsp;&emsp;确实 wasp 黄蜂 what a fass 这有什么关系 第十三集 secretsproper 适当 used up 用完了 trumpet 喇叭 tuck in 快吃吧 第十六集 musical instrumentsin the attic&emsp;&emsp;在阁楼上 used to&emsp;&emsp;过去常常 meant&emsp;&emsp;mean的过去式，表示…的意思 according&emsp;&emsp;手风琴 tune&emsp;&emsp;曲调 horn&emsp;&emsp;号角 blow&emsp;&emsp;吹 never mind&emsp;&emsp;没关系 stick to&emsp;&emsp;坚持 第十七集 frogs and worms and butterfliesplay at …&emsp;&emsp;游戏 wriggly&emsp;&emsp;蠕动的 第十八集 dressing uppowder&emsp;&emsp; 粉末 lipstick&emsp;&emsp;口红 come along&emsp;&emsp; 一起 it‘s time&emsp;&emsp;&emsp;是时候了 I beg your pardon&emsp;&emsp;不好意思，我没听清 第十九集 new shoesflowerbed&emsp;&emsp;花坛（鲜花的床） wheelbarrow&emsp;&emsp;手推车 flowerpot&emsp;&emsp;花盆 a pair of &emsp;&emsp;一双 draughts&emsp;&emsp;国际跳棋 pajamas&emsp;&emsp;睡衣 wet&emsp;&emsp;潮湿 grass&emsp;&emsp;草；草地 二十集 the school fetefete&emsp;&emsp;节日；游园会 bouncy&emsp;&emsp;有弹性的 castle&emsp;&emsp;城堡 pussycat&emsp;&emsp;小猫 instead&emsp;&emsp;代替 creep&emsp;&emsp;爬行 purr&emsp;&emsp;咕噜咕噜声 proper&emsp;&emsp;适当的 第二十一集 mummy pig‘s birthdaysitting room客厅 magazine杂志 the same number of相同数量的 candle蜡烛 whisper耳语；悄悄话 present礼物 theater戏剧 whole world全世界","link":"/2021/01/25/%E3%80%8A%E5%B0%8F%E7%8C%AA%E4%BD%A9%E5%A5%87%E3%80%8B%E5%90%AC%E5%8A%9B%E7%AC%94%E8%AE%B0/"},{"title":"关于昂克英文的英语学习方法论","text":"英语基础扎实，大量输入，大量输出。 基础基础都要掌握，才可以进行进阶学习。 三核心三核心对于英语的学习非常重要，但是在我们传统的英语学习中，经常会忽略这一部分。 音标 连读 语调 语法 词法 句法 常见积累量 单词量 阅读层面，听力层面，运用层面。 积累量 单词量，短语，句子。 高中毕业水平，证明基础还行。 输入听说 精听 跟读，听写 泛听 读写 精读 泛读 输出听说与人对话 读写仿写，实战写作 总结基础扎实，大量输入，大量输出。 大量的输入之后，慢慢的过渡到大量的输出。","link":"/2021/02/01/%E5%85%B3%E4%BA%8E%E6%98%82%E5%85%8B%E8%8B%B1%E6%96%87%E7%9A%84%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E8%AE%BA/"}],"tags":[{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"机器学习","slug":"机器学习","link":"/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"进化算法","slug":"进化算法","link":"/tags/%E8%BF%9B%E5%8C%96%E7%AE%97%E6%B3%95/"},{"name":"遗传算法","slug":"遗传算法","link":"/tags/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"提高效率","slug":"提高效率","link":"/tags/%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87/"},{"name":"计算机学习","slug":"计算机学习","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/"},{"name":"金融理财","slug":"金融理财","link":"/tags/%E9%87%91%E8%9E%8D%E7%90%86%E8%B4%A2/"},{"name":"书籍","slug":"书籍","link":"/tags/%E4%B9%A6%E7%B1%8D/"},{"name":"人生哲学","slug":"人生哲学","link":"/tags/%E4%BA%BA%E7%94%9F%E5%93%B2%E5%AD%A6/"},{"name":"个人杂谈","slug":"个人杂谈","link":"/tags/%E4%B8%AA%E4%BA%BA%E6%9D%82%E8%B0%88/"},{"name":"其他文章","slug":"其他文章","link":"/tags/%E5%85%B6%E4%BB%96%E6%96%87%E7%AB%A0/"},{"name":"英语学习","slug":"英语学习","link":"/tags/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/"}],"categories":[{"name":"效率教程","slug":"效率教程","link":"/categories/%E6%95%88%E7%8E%87%E6%95%99%E7%A8%8B/"},{"name":"书影音笔记","slug":"书影音笔记","link":"/categories/%E4%B9%A6%E5%BD%B1%E9%9F%B3%E7%AC%94%E8%AE%B0/"},{"name":"个人杂谈","slug":"个人杂谈","link":"/categories/%E4%B8%AA%E4%BA%BA%E6%9D%82%E8%B0%88/"},{"name":"其他文章","slug":"其他文章","link":"/categories/%E5%85%B6%E4%BB%96%E6%96%87%E7%AB%A0/"},{"name":"智能优化算法","slug":"智能优化算法","link":"/categories/%E6%99%BA%E8%83%BD%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/"}]}