{"pages":[{"title":"文章分类","text":"","link":"/categories/index.html"}],"posts":[{"title":"我的第一篇博客文章","text":"这是我的第一篇博客，好激动啊，我要笑一会！！ 哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈 参考文献www.codesheep.cnb站视频","link":"/2020/12/13/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"},{"title":"用Markdown编写博客指南","text":"1.关于博客日常改动，2.Markdown语法使用指南 关于博客日常改动在本地对博客进行修改（添加新博文、修改样式等等）后，通过Git进行管理 ​ 1.依次执行以下三条命令，同步到Github中 123git cgit ggit d Markdown语法使用指南（typora）代码块：123#在英文输入下，输入三个```+语言 ​```python​```java 1.python代码 1print(&quot;hello world!&quot;) 标题：123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 字体123**加粗**~~删除线~~*斜体* 加粗删除线斜体 引用12#引用语法&gt;作者 作者 分割线123//分割线---*** 图片插入12#在线图片，本地图片！[图片](图片地址或者url) 超链接12//超链接[我的网站](https://github.com/xuhaha456) 我的网站 列表123456#无序列表-目录1-目录2-目录3#有序列表1+.+名称 目录1 目录2 目录3 表格1#直接用软件插入，手写代码太麻烦 语文 数学 100 100","link":"/2020/12/14/%E7%94%A8Markdown%E7%BC%96%E5%86%99%E5%8D%9A%E5%AE%A2%E6%8C%87%E5%8D%97/"},{"title":"莫烦老师GA算法学习笔记","text":"如果让我用一句话概括遗传算法: 在程序里生宝宝, 杀死不乖的宝宝, 让乖宝宝继续生宝宝. 遗传算法下面为莫烦老师遗传算法源代码 中文注释均为徐哈哈同学在学习过程中，为了自身的学习，添加的笔记 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123import numpy as npimport matplotlib.pyplot as plt# ------------- 参数控制面板-----------DNA_SIZE = 10 # DNA lengthPOP_SIZE = 100 # population sizeCROSS_RATE = 0.8 # mating probability (DNA crossover)MUTATION_RATE = 0.003 # mutation probabilityN_GENERATIONS = 100X_BOUND = [0, 5] # x upper and lower bounds# --------函数集合----------def F(x): return np.sin(10 * x) * x + np.cos(2 * x) * x # to find the maximum of this function# find non-zero fitness for selectiondef get_fitness(pred): return pred + 1e-3 - np.min(pred)# 因为如果直接返回pred可能是负值，而我们在计算概率的时候不能为负值。# 要进行处理，np.min表示取最小，为最大的负数，可以使全部只变成正的；1e-3为了让float进行相除防止小数点后的数被省略# convert binary DNA to decimal and normalize it to a range(0, 5)# 对基因的翻译，如这里函数，x轴是实数，这里解释了如何将遗传0、1序列翻译成实数。用十进制二进制转换# pop (population)是一个储存二进制 DNA 的矩阵, 他的 shape 是这样 (pop_size, DNA_size)# 这里DNA_SIZE，X_BOUND是超参数def translateDNA(pop): return pop.dot(2 ** np.arange(DNA_SIZE)[::-1]) / float(2 ** DNA_SIZE - 1) * X_BOUND[1]def select(pop, fitness): # nature selection wrt pop's fitness idx = np.random.choice(np.arange(POP_SIZE), size=POP_SIZE, replace=True, p=fitness / fitness.sum()) # numpy.random.choice(a, size=None, replace=True, p=None) # 从a(只要是nparray都可以，但必须是一维的)中随机抽取数字，并组成指定大小(size)的数组 # replace:True表示可以取相同数字，False表示不可以取相同数字 # 数组p：与数组a相对应，表示取数组a中每个元素的概率，默认为选取每个元素的概率相同。 # 这里概率不能为负，所以pred要进行非负处理 # replace表示抽样后是否放回，这里为True表示有放回，则可能会出现相同的索引值 # p 就是选它的比例，按比例来选择适应度高的,也会保留一些适应度低的，因为也可能后面产生更好的变异 # np.random.choice表示从序列中取值 np.arange()函数返回一个有终点和起点的固定步长的排列 return pop[idx]def crossover(parent, pop): # mating process (genes crossover) if np.random.rand() &lt; CROSS_RATE: i_ = np.random.randint(0, POP_SIZE, size=1) # select another individual from pop cross_points = np.random.randint(0, 2, size=DNA_SIZE).astype(np.bool) # choose crossover points parent[cross_points] = pop[i_, cross_points] # mating and produce one child return parentdef mutate(child): for point in range(DNA_SIZE): if np.random.rand() &lt; MUTATION_RATE: child[point] = 1 if child[point] == 0 else 0 return child# --------------------主程序开始--------------------------------pop = np.random.randint(2, size=(POP_SIZE, DNA_SIZE)) # initialize the pop DNA# np.ransom.randint函数是随机生成[0，2）之间，长度为DNA_SIZE的向量POP_SIZE个# size=（a，b，c）c为一维向量数量，b为二维向量的数量，a为三维向量的数量# 例[[1010101010]# [1011101001]# ...]plt.ion() # something about plotting# 在使用matplotlib的过程中，不能像matlab一样同时开几个窗口进行比较，可以采用交互模式，但是放在脚本里运行一闪而过，图像并不停留# python可视化库matplotlib有两种显示模式：阻塞（block）模式&amp;交互（interactive）模式# 在交互模式下：plt.plot(x)或plt.imshow(x)是直接出图像，不需要plt.show()# 如果在脚本中使用ion()命令开启了交互模式，没有使用ioff()关闭的话，则图像不会常留。防止这种情况，需要在plt.show()之前加上ioff()命令。# 在阻塞模式下：打开一个窗口以后必须关掉才能打开下一个新的窗口。这种情况下，默认是不能像Matlab一样同时开很多窗口进行对比的# plt.plot(x)或plt.imshow(x)是直接出图像，需要plt.show()后才能显示图像x = np.linspace(*X_BOUND, 200)# np.linspace()函数是在a，b范围，平均取c个数，作为矩阵x的元素（a，b，c）# X_BOUND = [0, 5],要产生200个样本点plt.plot(x, F(x))# 在交互模式下：plt.plot(x)或plt.imshow(x)是直接出图像，不需要plt.show()for _ in range(N_GENERATIONS): # for _ in range(N_GENERATIONS):中_为临时变量 # 效果和for i in range(N_GENERATIONS):一样 F_values = F(translateDNA(pop)) # compute function value by extracting DNA # something about plotting if 'sca' in globals(): sca.remove() sca = plt.scatter(translateDNA(pop), F_values, s=200, lw=0, c='red', alpha=0.5); # scatter函数就是在函数图像上画出当前种群每个个体对应的（x，y）的位置 # 参数列表（x，y，s为散点面积，lw未知，c为颜色，alpha为透明度） plt.pause(0.05) # 控制图像停留时间 # GA part (evolution) fitness = get_fitness(F_values) print(&quot;Most fitted DNA: &quot;, pop[np.argmax(fitness), :]) pop = select(pop, fitness) pop_copy = pop.copy() for parent in pop: child = crossover(parent, pop_copy) child = mutate(child) parent[:] = child # parent is replaced by its childplt.ioff()plt.show()# 展示最后一代的个体所在图像位置# 数字作为变量在程序中称为幻数，尽量减少程序中以幻数作为变量的出现# 总体算法过程# 初始化种群-&gt;绘制函数曲线-&gt;开始进入for循环# for循环里# 计算每一点函数值-&gt;把每一点打印在图上-&gt;计算适应度-&gt;根据适应度选择-&gt;交叉变异# 数据结构过程# 初始种群pop-&gt;计算每一个体的y值-&gt;通过y值计算每一个体的适应度-&gt;对个体进行选择-&gt;繁衍交叉变异# 此算法缺陷1：种群个体x值在translateDNA时，默认全部翻译为正数。若函数最大值在二三象限，此算法无法找出最优解，即使修改# x的界限，也无济于事。# 解决办法1：在translateDNA函数中引入（0，1）符号位定义，并加入if判断，判断条件为符号位数值为1，且x界限最小值为负数，# 若条件为真，就将其翻译为负值，否则，翻译结果保持不变。 对遗传算法缺陷1做出改进以下为哈哈同学对遗传算法缺陷1提供的解决方案 123456789101112131415161718192021222324252627&quot;&quot;&quot;此算法已完全实现缺陷1的解决方案，经过多轮测试，无明显且常见错误出现此算法在原有GA算法的基础上，只对plt.pause()函数和translateDNA函数进行修改，translateDNA函数相关修改说明写于translateDNA函数附近，plt.pause()函数将时间参数从0.05调整为0.001.&quot;&quot;&quot;def translateDNA(pop): pop_l = pop.dot(2 ** np.arange(DNA_SIZE)[::-1]) / float(2 ** DNA_SIZE - 1) * (X_BOUND[1] - X_BOUND[0]) if X_BOUND[0] &lt; 0: for i in range(POP_SIZE): if pop[i, 0] == 1: pop_l[i] = (-1) * (pop_l[i] - 512 / float(2 ** DNA_SIZE - 1) * (X_BOUND[1] - X_BOUND[0])) return pop_l&quot;&quot;&quot;在原有算法的基础上，此算法将基因的首位二进制数作为符号位，其中0代表正数，1代表负数。第一行：创建临时矩阵pop_l，临时用于保存pop进行二—十进制翻译后数值结果第二行提前判断x的取值，目的是为了当函数定义域在x轴正半轴时，跳过循环，加快算法运算速度第三行到第五行代码将遍历整个pop矩阵，对每一个基因向量的符号位做出判断如果某一基因向量的符号位为一，则对表现型矩阵pop_l中相应数值取负值，因为符号位也参与到了二—十进制的翻译所以通过pop_l[i] - 512 / float(2 ** DNA_SIZE - 1) * (X_BOUND[1] - X_BOUND[0])减去负数符号位对数值的影响因为正数符号位为0，所以不用考虑正数对最终数值的影响。&quot;&quot;&quot;plt.pause(0.001) # 将时间参数从0.05修改为0.001 例子 配对句子以下为莫烦老师的源代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import numpy as npTARGET_PHRASE = 'You get it!' # target DNAPOP_SIZE = 300 # population sizeCROSS_RATE = 0.4 # mating probability (DNA crossover)MUTATION_RATE = 0.01 # mutation probabilityN_GENERATIONS = 1000DNA_SIZE = len(TARGET_PHRASE)TARGET_ASCII = np.fromstring(TARGET_PHRASE, dtype=np.uint8) # convert string to numberASCII_BOUND = [32, 126]class GA(object): def __init__(self, DNA_size, DNA_bound, cross_rate, mutation_rate, pop_size): self.DNA_size = DNA_size DNA_bound[1] += 1 self.DNA_bound = DNA_bound self.cross_rate = cross_rate self.mutate_rate = mutation_rate self.pop_size = pop_size self.pop = np.random.randint(*DNA_bound, size=(pop_size, DNA_size)).astype(np.int8) # int8 for convert to ASCII def translateDNA(self, DNA): # convert to readable string return DNA.tostring().decode('ascii') def get_fitness(self): # count how many character matches match_count = (self.pop == TARGET_ASCII).sum(axis=1) return match_count def select(self): fitness = self.get_fitness() + 1e-4 # add a small amount to avoid all zero fitness idx = np.random.choice(np.arange(self.pop_size), size=self.pop_size, replace=True, p=fitness/fitness.sum()) return self.pop[idx] def crossover(self, parent, pop): if np.random.rand() &lt; self.cross_rate: i_ = np.random.randint(0, self.pop_size, size=1) # select another individual from pop cross_points = np.random.randint(0, 2, self.DNA_size).astype(np.bool) # choose crossover points parent[cross_points] = pop[i_, cross_points] # mating and produce one child return parent def mutate(self, child): for point in range(self.DNA_size): if np.random.rand() &lt; self.mutate_rate: child[point] = np.random.randint(*self.DNA_bound) # choose a random ASCII index return child def evolve(self): pop = self.select() pop_copy = pop.copy() for parent in pop: # for every parent child = self.crossover(parent, pop_copy) child = self.mutate(child) parent[:] = child self.pop = popif __name__ == '__main__': ga = GA(DNA_size=DNA_SIZE, DNA_bound=ASCII_BOUND, cross_rate=CROSS_RATE, mutation_rate=MUTATION_RATE, pop_size=POP_SIZE) for generation in range(N_GENERATIONS): fitness = ga.get_fitness() best_DNA = ga.pop[np.argmax(fitness)] best_phrase = ga.translateDNA(best_DNA) print('Gen', generation, ': ', best_phrase) if best_phrase == TARGET_PHRASE: break ga.evolve() 例子 旅行商问题(TSP)以下为莫烦老师的源代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495import matplotlib.pyplot as pltimport numpy as npN_CITIES = 20 # DNA sizeCROSS_RATE = 0.1MUTATE_RATE = 0.02POP_SIZE = 500N_GENERATIONS = 5000class GA(object): def __init__(self, DNA_size, cross_rate, mutation_rate, pop_size, ): self.DNA_size = DNA_size self.cross_rate = cross_rate self.mutate_rate = mutation_rate self.pop_size = pop_size self.pop = np.vstack([np.random.permutation(DNA_size) for _ in range(pop_size)]) def translateDNA(self, DNA, city_position): # get cities' coord in order line_x = np.empty_like(DNA, dtype=np.float64) line_y = np.empty_like(DNA, dtype=np.float64) for i, d in enumerate(DNA): city_coord = city_position[d] line_x[i, :] = city_coord[:, 0] line_y[i, :] = city_coord[:, 1] return line_x, line_y def get_fitness(self, line_x, line_y): total_distance = np.empty((line_x.shape[0],), dtype=np.float64) for i, (xs, ys) in enumerate(zip(line_x, line_y)): total_distance[i] = np.sum(np.sqrt(np.square(np.diff(xs)) + np.square(np.diff(ys)))) fitness = np.exp(self.DNA_size * 2 / total_distance) return fitness, total_distance def select(self, fitness): idx = np.random.choice(np.arange(self.pop_size), size=self.pop_size, replace=True, p=fitness / fitness.sum()) return self.pop[idx] def crossover(self, parent, pop): if np.random.rand() &lt; self.cross_rate: i_ = np.random.randint(0, self.pop_size, size=1) # select another individual from pop cross_points = np.random.randint(0, 2, self.DNA_size).astype(np.bool) # choose crossover points keep_city = parent[~cross_points] # find the city number swap_city = pop[i_, np.isin(pop[i_].ravel(), keep_city, invert=True)] parent[:] = np.concatenate((keep_city, swap_city)) return parent def mutate(self, child): for point in range(self.DNA_size): if np.random.rand() &lt; self.mutate_rate: swap_point = np.random.randint(0, self.DNA_size) swapA, swapB = child[point], child[swap_point] child[point], child[swap_point] = swapB, swapA return child def evolve(self, fitness): pop = self.select(fitness) pop_copy = pop.copy() for parent in pop: # for every parent child = self.crossover(parent, pop_copy) child = self.mutate(child) parent[:] = child self.pop = popclass TravelSalesPerson(object): def __init__(self, n_cities): self.city_position = np.random.rand(n_cities, 2) plt.ion() def plotting(self, lx, ly, total_d): plt.cla() plt.scatter(self.city_position[:, 0].T, self.city_position[:, 1].T, s=100, c='k') plt.plot(lx.T, ly.T, 'r-') plt.text(-0.05, -0.05, &quot;Total distance=%.2f&quot; % total_d, fontdict={'size': 20, 'color': 'red'}) plt.xlim((-0.1, 1.1)) plt.ylim((-0.1, 1.1)) plt.pause(0.01)ga = GA(DNA_size=N_CITIES, cross_rate=CROSS_RATE, mutation_rate=MUTATE_RATE, pop_size=POP_SIZE)env = TravelSalesPerson(N_CITIES)for generation in range(N_GENERATIONS): lx, ly = ga.translateDNA(ga.pop, env.city_position) fitness, total_distance = ga.get_fitness(lx, ly) ga.evolve(fitness) best_idx = np.argmax(fitness) print('Gen:', generation, '| best fit: %.2f' % fitness[best_idx],) env.plotting(lx[best_idx], ly[best_idx], total_distance[best_idx])plt.ioff()plt.show()","link":"/2020/12/15/%E8%8E%AB%E7%83%A6%E8%80%81%E5%B8%88GA%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"Hexo和icarus主题那些坑：访问慢、添加ICP备案号","text":"1.icarus主题打开慢 2.如何设置ICP备案代码 icarus主题打开慢换了icarus主题后，没有科学上网的情况下打开非常慢，基本打开不了。后来通过查看浏览器请求，发现是一些字体、css文件请求失败的原因： 找到_config.icarus.yml，在最后的providers，修改：全部修改为loli 1234567providers: # Name or URL template of the JavaScript and/or stylesheet CDN provider cdn: loli # Name or URL template of the webfont CDN provider fontcdn: loli # Name or URL of the fontawesome icon font CDN provider iconcdn: loli 找到themes/icarus/layout/common/head.jsx 注释掉： default: fontcdn(‘Ubuntu:wght@400;600&amp;family=Source+Code+Pro’, ‘css2’), 1234const fontCssUrl = { // default: fontcdn('Ubuntu:wght@400;600&amp;family=Source+Code+Pro', 'css2'), cyberpunk: fontcdn('Oxanium:wght@300;400;600&amp;family=Roboto+Mono', 'css2')}; ICP备案显示博客之前一直部署在github服务器上，github部署虽然免费，但是在国内访问博客速度奇慢。关于访问太慢的问题，想过两套方案解决。一是配合国内gitee服务器实现双部署，访问速度提高了，但是gitee服务器不支持自动更新，每次部署完都要手动更新。二是直接购买云服务器，将网站部署在云服务器上，访问速度提上来了，但是云服务器每年的租金又是一笔开销。 在今年双十二期间，腾讯云活动服务器一年只要99元，比学生认证购买还要便宜，直接下单，网站整体搬迁到云服务器上。国内的法律规定，把网站部署到云服务器上需要在省网信部备案，经过几天的等待，备案审核终于通过了，现在只要把备案号添加到网站底部，网站就可以正常投放到互联网上了。 当我准备把备案号加在网站底部时发现，icarus这个主题竟然没有添加备案号的接口，没办法，只能上网找资料自己修改源文件，把这个接口写上了。 一、寻找相关文件在themes/icarus/layout/common路径下找到footer.jsx文件 二、修改源代码123456789101112 {footerLogo} &lt;/a&gt;//找到这个位置，并把以下源代码插入到这个位置 &lt;p class=&quot;is-size-7&quot;&gt; &lt;span dangerouslySetInnerHTML={{ __html: `&amp;copy; ${siteYear} ${author || siteTitle}` }}&gt;&lt;/span&gt; &amp;nbsp;&amp;nbsp;Powered by &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;&amp;nbsp;&amp;&amp;nbsp; &lt;a href=&quot;https://github.com/ppoffice/hexo-theme-icarus&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Icarus&lt;/a&gt; {showVisitorCounter ? &lt;br /&gt; : null} {showVisitorCounter ? &lt;span id=&quot;busuanzi_container_site_uv&quot; dangerouslySetInnerHTML={{ __html: visitorCounterTitle }}&gt;&lt;/span&gt; : null} &lt;/p&gt; 123456//被插入源代码&lt;p class=&quot;size-small&quot;&gt; &lt;a href=&quot;http://www.beian.miit.gov.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;冀ICP备XXXXXXX&lt;/a&gt; &lt;span class=&quot;post-meta-divider&quot;&gt;&amp;nbsp;|&amp;nbsp;&lt;/span&gt; &lt;a target=&quot;_blank&quot; href=&quot;http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=XXXXXXXXXX&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;你的网站地址/img/beian.png&quot; /&gt; 冀公网安备 XXXXXXXXX号&lt;/a&gt; &lt;/p&gt; 三、注意事项1.源代码打开用vscode ，不要用其他编辑器，因为vscode编辑器文本默认保存格式为UFT-8，其他编译器默认文本保存格式若不是UFT-8，在网站上会出现乱码显示 2.将源代码调整合适","link":"/2020/12/16/Hexo%E5%92%8Cicarus%E4%B8%BB%E9%A2%98%E9%82%A3%E4%BA%9B%E5%9D%91%EF%BC%9A%E8%AE%BF%E9%97%AE%E6%85%A2%E3%80%81%E6%B7%BB%E5%8A%A0ICP%E5%A4%87%E6%A1%88%E5%8F%B7/"},{"title":"Git学习与使用指南","text":"大名鼎鼎的Git软件，长期以来获得计算机从业人员的广泛关注，它帮助从业者实现高效率的代码版本管理，大大提高开发效率 Git广泛运用于对脚本文件的管理，但是对于word，excal，powerpoint等非脚本文件的管理，Git却无能为力 Git安装因为笔者的设备为一台windows电脑与一台linux系统的服务器，所以笔者在这里只提供Windows 和 linux的安装教程，macos系统的安装过程与windows一样，在这就不再赘述了。 windows安装直接官网安装，打开官网自动推荐适合的版本，安装包next到底就可以 git官网 安装好之后里面会有一个git文件夹里面会有一个程序叫做 git bush. 这个 git bush 是 git 在 Windows 上为了方便使用所设置的一个 Unix 的环境. 如果你是 Windows 用户, 之后的教程你也能用这个来学习使用 git. linux安装使用 Linux 的朋友们, 大家肯定都很熟悉怎么在 Linux 上装东西, 所以只要找到你的 Terminal, 并输入以下指令就可以啦: 12345# 如果你的 Linux 是 Ubuntu:$ sudo apt-get install git-all# 如果你的 Linux 是 Fedora:$ sudo yum install git-all linux 更多版本安装教程，请看这里：git官方文档 Git配置git在使用之前，需要配置git用户名和邮箱，这样方便后期代码版本的准确溯源 在git bush界面输入如下代码 12git config --global user.name&quot;xuhaha&quot;git congig --global user.email&quot;xuhaha@163.com&quot; 这两行代码配置的用户名和邮箱均为全局变量，之后在同一台设备建立仓库默认的用户名就为这个，无需再次设置。 12git config user.namegit config user.email 这两行代码为查询用户名和邮箱，用来检验用户名和邮箱配置是否正确 Git运行流程git运行流程为，在本地创建一个文件夹，作为版本库，这就是我们本地的工作空间，在这个空间中对文件进行一系列操作。之后将修改好的文件添加到缓存区，文件在缓存区中做最后一步的准备，准备被提交到本地仓库。 创建版本库（workspace）在此，版本库就是工作空间，工作空间就是版本库 我们先确定将文件放在哪个文件夹管理，比如我们在桌面新建一个文件夹，命名为gitTest，然后在Terminal或者git bush中打开这个文件夹，之后在文件夹中建立git管理文件 打开目标文件夹： 1cd ~/desktop/gitTest 创建版本库： 1git init 此时，文件夹中多了一个隐藏文件夹 .git 这就是一个空的git管理库 添加文件到缓存区(index)我们继续在文件夹里创建一个新文件，可以直接拖进来现有文件，也可以用命令行生成一个人新文件 1touch 1.py 现在我们用git status查看版本库的状态 12345678910111213$ git status# 输出On branch master # 在 master 分支Initial commitUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) 1.py # 1.py 文件没有被加入版本库 (unstaged)nothing added to commit but untracked files present (use &quot;git add&quot; to track) 现在 1.py 并没有被放入缓存区中 (unstaged), 所以我们要使用 add 把它添加进缓存区 (staged) 1234567891011121314$ git add 1.py# 再次查看状态 status$ git status# 输出On branch masterInitial commitChanges to be committed: (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage) new file: 1.py # 版本库已识别 1.py (staged) 如果想一次性添加文件夹中所有未被添加的文件, 可以使用这个 1git add . 提交文件更改到仓库（Head）这一步骤，将我们已经更改好，并且已经添加到缓存区的文件，直接提交到仓库中。 1git commit -m &quot;create 1.py&quot;//对此次提交的描述 这一个步骤直接将缓存区中所有的脚本文件一并提交到我们本地的仓库中。 查看脚本文件提交修改记录在这一步之前，我们已经在文件夹中，也就是我们的工作空间生成了一个1.py的文件，并将文件添加到了缓存区，然后提交到了仓库。这时我们可以通过以下命令来查看我们的提交记录 1git log git bash 为我们返回以下信息 1234567$ git logcommit 5b3d0a8ca8747d499e81f90e78b50b1f1ba3870d (HEAD -&gt; master)Author: xuhaha &lt;xuhhaa@gmail.com&gt;Date: Fri Dec 18 00:08:48 2020 +0800 create 1.py 通过这一条命令，我们可以详细的知道文件的提交修改信息，提交信息中包括修改者的信息，以及修改的时间。 如果我们在本地对1.py进行一次修改，添加如下代码 1print(&quot;gitis a new software&quot;) 我们将1.py文件再次添加到缓存区，并提交到仓库，之后运用log可以看到如下的修改信息： 12345678910111213$ git logcommit 111e648cef761980f1fb95b2b2dceecdcc1e03e3 (HEAD -&gt; master)Author: xuhaha &lt;xuhhaa@gmail.com&gt;Date: Fri Dec 18 00:15:08 2020 +0800 change 1commit 5b3d0a8ca8747d499e81f90e78b50b1f1ba3870dAuthor: xuhaha &lt;xuhhaa@gmail.com&gt;Date: Fri Dec 18 00:08:48 2020 +0800 create 1.py 现在我们就能看到 create 1.py 和 change 1 这两条修改信息了. 而且做出这两条 commit 的 ID, 修改的 Author, 修改 Date也被显示在上面. 查看文件修改前后的不同与仓库中的文件对比还没有add到缓存区如果在本地修改后的脚本文件还没有添加到缓存区，我们想知道此时的脚本文件和上一个已经提交的文件有何不同，我们可以使用以下命令来查看区别，在查看之前，我们先在脚本文件中作出一些修改，我们在文件中添加a=2这一条语句 1git diff 运行上面这条命令，我们可以获得以下信息 12345678910111213$ git diffdiff --git a/1.py b/1.pyindex 507924c..ab4fd96 100644--- a/1.py+++ b/1.py@@ -1 +1,2 @@-print(&quot;gitis a new software&quot;)\\ No newline at end of file+print(&quot;gitis a new software&quot;)^M+a=2\\ No newline at end of file 上面的信息就显示出来了，和上一次提交的版本相比，我们又多加了一条语句 add到缓存区如果我们已经将修改过后的文件添加到了缓存区，我们可以在diff后添加–cached来查看修改 123456789101112$ git diff --cacheddiff --git a/1.py b/1.pyindex 507924c..ab4fd96 100644--- a/1.py+++ b/1.py@@ -1 +1,2 @@-print(&quot;gitis a new software&quot;)\\ No newline at end of file+print(&quot;gitis a new software&quot;)^M+a=2\\ No newline at end of file 与缓存区中的文件对比还有种方法让我们可以查看 add 过和 没 add 的修改, 比如我们再修改一下 1.py 但不 add: 123print(&quot;gitis a new software&quot;)a=2b=3 目前第一，二条两条语言已经被add，第三条语言为新的修改，还没有被add 我们可以通过以下命令查看add和为被add的区别 1git diff HEAD 1234567891011121314$ git diff HEADdiff --git a/1.py b/1.pyindex 507924c..810d217 100644--- a/1.py+++ b/1.py@@ -1 +1,3 @@-print(&quot;gitis a new software&quot;)\\ No newline at end of file+print(&quot;gitis a new software&quot;)^M+a=2^M+b=3\\ No newline at end of file 为了以下内容进行，我们将全部内容提交到仓库，并对这次提交描述为change 2 文件属性的划分在此我插一句，在之前你可能会看到文章出现staged unstaged等字样，这些字样描述的是文件此时被修改后所处的不同位置，被修改后的版本是在仓库中还是在缓存区，或者是在我们的工作空间，这样的描述字眼一共有四个，在此我一一解释： untracked：此时被修改的文件存放在工作空间中，还没有add到缓存区，也没有commit到仓库中。 staged：此时被修改的文件已经add到了缓存区，但是此时还没有commit到仓库中。 Unmodified：此时被修改的文件已经commit到了仓库，并且文件保持着未被修改的状态 modified:当文件已经被保存到仓库中，此时文件仅仅被修改了，文件就会转化为此状态 modified和unstracked的区别：文件别修改，若文件的修改前版本没有在仓库中，则显示unstracked状态，若文件的修改前版本在仓库中，则显示modified状态。 修改已经提交的版本在写代码的时候，有时我们一走神就会忘记一些什么。比如我们已经将缓存区里面的文件commit提交到了仓库中，文件也已经变成了unmodified状态。这时我们发现有一个附加文件忘记提交到仓库中，或者这时我们提交之后紧接着修改了源代码，我们此时又不想重复提交，增加修改记录，这时我们就可以通过下面一条命令，将文件提交到上一次的修改记录。 1git commit --amend --no-edit #&quot;--no-edit&quot;: 不编辑, 直接合并到上一个 commit 在提交之前我们先对文件做出一点改变，我们将1.py文件复制一个副本出来，命名为2.py，同时我们也对1.py文件做出更改，添加以下命令。 1c=4 运行添加，提交命令，并用git log查看，得到如下反馈 1234$ git log --oneline # &quot;--oneline&quot;: 每个 commit 内容显示在一行689d32f (HEAD -&gt; master) change 2111e648 change 15b3d0a8 create 1.py 将缓存区的文件拉出来有时我们已经将文件添加到了缓存区，但是我们突然还想补充一些内容再将文件添加到缓存区，我们还可以通过以下的方式回到add以前，比如我们在1.py中添加这样的一行 1d=5 然后将文件添加到缓存区，再返回到add之前 12345678910111213$ git add 1.py$ git status -s # &quot;-s&quot;: status 的缩写模式# 输出M 1.py # staged-----------------------$ git reset 1.py #reset 将文件从缓存区拉出来，就是从staged到modified# 输出Unstaged changes after reset:M 1.py-----------------------$ git status -s# 输出 M 1.py # unstaged 回到之前提交的版本有时候，我们的代码可能越写越糟糕，如果我们想回到更改之前的某一次提交版本，怎么办呢，这时我们可以通过reset实现版本穿越，接下来看看如何实现版本穿越。 在穿梭到过去的版本之前，我们必须要了解一下git是如何一步一步累加更改的，我们截取网上的一些图片。 master不用管什么意思，在下面的内容中会讲解到master是什么 通过git log --oneline命令我们可以查看到，我们的每一次提交都有id号码，HEAD是一个指针，学习过c语言的同学应该对指针不陌生，指引当前的状态在哪一次提交，最进的一次提交在commit的最右面，了解原理，实现版本穿梭就不难了，我们可以调整指针HEAD的位置，回到过去的版本。 1234567891011121314151617181920#通过以下命令查看当前HEAD指针所在的位置$ git reset --hard HEADHEAD is now at 689d32f change 2#查看所有的修改记录$ git log --oneline0e69ed4 (HEAD -&gt; master) change 2111e648 change 15b3d0a8 create 1.py# 回到 111e648 change 1# 方式1: &quot;HEAD^&quot;$ git reset --hard HEAD^ # 方式2: &quot;commit id&quot;$ git reset --hard 111e648# 看看现在的 log$ git log --oneline# 输出111e648 change 15b3d0a8 create 1.py 此时我们发现change 2消失不见了，我们还有办法补救消失的change 2吗？ 我们可以通过git reflog查看HEAD的所有改动，我们可以再次通过reset回到change 2这一步了 因为我的HEAD记录记录在写教程之前就变动了多次，产生了众多的记录，所以我就借此说一说HEAD作为指针是如何工作的。 123456789101112131415161718$ git reflog689d32f (HEAD -&gt; master) HEAD@{0}: reset: moving to 689d32f0e69ed4 HEAD@{1}: reset: moving to 0e69ed4689d32f (HEAD -&gt; master) HEAD@{2}: reset: moving to HEAD689d32f (HEAD -&gt; master) HEAD@{3}: reset: moving to 689d32f0e69ed4 HEAD@{4}: reset: moving to 0e69ed4689d32f (HEAD -&gt; master) HEAD@{5}: reset: moving to 689d32f5b3d0a8 HEAD@{6}: reset: moving to HEAD5b3d0a8 HEAD@{7}: reset: moving to 5b3d0a85b3d0a8 HEAD@{8}: reset: moving to HEAD^111e648 HEAD@{9}: reset: moving to HEAD^689d32f (HEAD -&gt; master) HEAD@{10}: reset: moving to HEAD689d32f (HEAD -&gt; master) HEAD@{11}: commit (amend): change 2b155394 HEAD@{12}: commit (amend): change 20e69ed4 HEAD@{13}: commit: change 2111e648 HEAD@{14}: commit: change 15b3d0a8 HEAD@{15}: commit (initial): create 1.py 通过git reflog查看所有的指针移动记录，我们发现记录虽然有很多条，但是提交版本的id不变，反反复复就那几个重复出现，这是因为提交版本的id就直接引用了内存的地址编码，这样就更好的理解了HEAD作为指针是如何移动的了。最后一条记录也显示，我们最终回到了change 2. 将单个文件回到过去版本我们现在知道了，如果想回到之前的提交版本，我们可以利用reset回到之前我们已经提交的任意一个版本，但是如果我们只想对工作空间中的其中一个文件实现版本穿梭，而其他文件保持当前的版本不变，我们应该怎么做呢？这时我们就可以通过checkout来实现。 我们仅仅要对1.py实现版本穿梭的操作，回到change 1这一个提交版本，使用git checkout+111e648 +-- 1.py我们就可以调整1.py的指针回到change 1. 1234567$ git log --oneline689d32f (HEAD -&gt; master) change 2111e648 change 15b3d0a8 create 1.py$ git checkout 111e648 -- 1.py 此时我们打开文件就会发现，1.py的文件内容已经变成了change 1时的信息。 1print(&quot;gitis a new software&quot;) 我们在 1.py 加上一行内容 # I went back to change 1 然后 add 并 commit 1.py: 123456789$ git add 1.py$ git commit -m &quot;back to change 1 and add comment for 1.py&quot;$ git log --oneline#输出23e5b56 (HEAD -&gt; master) back to change 1 and add comment for 1.py689d32f change 2111e648 change 15b3d0a8 create 1.py 可以看出, 不像 reset 时那样, 我们的 change 2 并没有消失, 但是 1.py 却已经回去了过去, 并改写了未来. 这就是reset和checkout的区别 分支（branch）git 的分支就像树的树枝一样，不同的分支下有不一样的脚本文件，我们在这之前做的所有的修改都是在master分支上进行的，我们可以在创立一个分支development，将代码稳定版本放在master上，将我们的开发版本放在dev上，这样就方便我们通过一个文件，实现对不同版本的管理。 查看分支在此之前我们只有一个分支master，我们可以通过以下命令来查看现有的分支，及其所包含的文件。 1234567891011$ git log --oneline --graph* 23e5b56 (HEAD -&gt; master) back to change 1 and add comment for 1.py* 689d32f change 2* 111e648 change 1* 5b3d0a8 create 1.py$ git log --oneline23e5b56 (HEAD -&gt; master) back to change 1 and add comment for 1.py689d32f change 2111e648 change 15b3d0a8 create 1.py 通过对比两次输出结果我们可以发现，添加–graph后，文件前面多了*号。 *号代表的就是主分支的意思。 创建分支123456$ git branch dev # 建立 dev 分支$ git branch # 查看当前分支# 输出 dev * master # * 代表了当前的 HEAD 所在的分支 切换分支当我们想把HEAD切换到dev去的时候，我们可以用到之前所说的checkout： 123456$ git checkout devSwitched to branch 'dev'$ git branch* dev#此时HEAD已经切换到了dev分支 master 这里我们还可以通过一种方法直接创建并切换到新建的分支 使用 checkout -b + 分支名, 就能直接创建和切换到新建的分支: 12345678910$ git checkout -b dev# 输出Switched to a new branch 'dev'--------------------------$ git branch# 输出* dev # 这时 HEAD 已经被切换至 dev 分支 master 在其他分支中修改dev 分支中的 1.py 和 2.py 和 master 中的文件是一模一样的. 因为当前的指针 HEAD 在 dev 分支上, 所以现在对文件夹中的文件进行修改将不会影响到 master 分支. 我们在 1.py 上加入这一行 # I was changed in dev branch, 然后再 commit: 1$ git commit -am &quot;change 3 in dev&quot; # &quot;-am&quot;: add 所有改变 并直接 commit 将 dev 的修改推送到 master好了, 我们的开发板本 dev 已经更新好了, 我们要将 dev 中的修改推送到 master 中, 大家就能使用到正式版中的新功能了. 首先我们要切换到 master, 再将 dev 推送过来. 1234567891011$ git checkout master # 切换至 master 才能把其他分支合并过来$ git merge dev # 将 dev merge 到 master 中$ git log --oneline --graph# 输出* f9584f8 change 3 in dev* 47f167e back to change 1 and add comment for 1.py* 904e1ba change 2* c6762a1 change 1* 13be9a7 create 1.py 要注意的是, 如果直接 git merge dev, git 会采用默认的 Fast forward 格式进行 merge, 这样 merge 的这次操作不会有 commit 信息. log 中也不会有分支的图案. 我们可以采取 --no-ff 这种方式保留 merge 的 commit 信息. 123456789101112$ git merge --no-ff -m &quot;keep merge info&quot; dev # 保留 merge 信息$ git log --oneline --graph# 输出* c60668f keep merge info|\\ | * f9584f8 change 3 in dev # 这里就能看出, 我们建立过一个分支|/ * 47f167e back to change 1 and add comment for 1.py* 904e1ba change 2* c6762a1 change 1* 13be9a7 create 1.py Githubgithub是非常强大的开源社区，我们可以将我们的文件从我们的本地仓库上传到云端服务器进行管理 github使用包括以下几个步骤 git在第一次尝试与github服务器连接的时候，会让你进行github登录，这时登录自己的账号就可以了，以后在这台电脑上与github连接就无需再次登陆了 克隆仓库： 123#新建文件夹，并在文件夹下创建新仓库git initgit clone url #url为被克隆仓库地址 推送文件到github仓库： 1234567#如果已经克隆现有仓库git push origin master#可以把master换成任何分支#没有克隆现有仓库，并欲将你的仓库连接到github远程服务器#你可以在本地使用如下命令添加github服务器：git remote add origin url.git #url为仓库地址git push origin master 将github服务器文件拉进本地目录 1git pull 参考文献： git - 简易指南 Pro Git（中文版） 莫烦python，Git 版本管理","link":"/2020/12/17/Git%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"title":"关于喜欢，这一情感”","text":"b站上一位作家，引发了我一点点的思考 ​ 哲学，是研究世界的一门学科，研究哲学有一个非常明确的观点就是，一个观点，无论你认为有么的荒谬，也不要直接去否定它。你首先要做的应该是，先去了解他提出的这个观点，了解提出观点的背景，了解提出这个观点的原因，进而对他发表你自己的看法。发表言论的前提，是我们需要对这件事情有足够的认识，在如今互联网时代更是如此，做一个合格网民的前提是要做一名合格的读者，在网络上时刻保持清醒，时刻保持独立思考。 ​ 关于喜欢，喜欢的对象可以是人，可以是领域，可以是任何物质，我之前在b站看到一个视频，视频的作者是一名文字工作者，作者非常喜欢写作，在视频里他谈到了这么多年他与写过的缘分，他说当他在写作的时候，他会感觉非常放松，在学生期间，他每天最放松的事情就是躺在床上，构思他的小说内容，可以看出来，这位作者非常喜欢写作，但是当时我听到这段的时候，我就在想，喜欢对一个人的影响这有这么大吗，直到我发现自己喜欢的领域是计算机的时候，我才突然明白作者当时的感受，原来，尽早的找到自己喜欢的事物，真是非常幸福的一件事，对于喜欢的事情，内心会不自觉的为它设立目标，在繁忙的日子里，每天最期待的事情就是自己喜欢的事情，真的就像孔子所说，“知之者不如好之者，好之者不如乐之者”。孔子的这句话也警醒着我们广大的青年朋友，在未来的人生规划，职业选择上，甚至是高考报志愿，对于行业的选择 ，对于专业的选择，喜欢才是选择的决定性标准，我们这一辈子应该追求的，也不止是金钱。根据二八定律，平凡的人永远占据着世界的八成。做自己所爱，不为金钱左右自己的热爱，在自己所热爱的行业里爱的彻底，走只属于自己的道路，在自己的道路上走到极致，人生一样会非常精彩，还会精彩的与众不同","link":"/2020/12/19/%E5%85%B3%E4%BA%8E%E5%96%9C%E6%AC%A2%EF%BC%8C%E8%BF%99%E4%B8%80%E6%83%85%E6%84%9F%E2%80%9D/"},{"title":"编程自学之路（持续更新中）","text":"我个人的编程自学指南，我会在这里记录我自学编程路上的点点滴滴 2021年自学之路 整体计划以年和月作为计划分界 实际行动以周和天进行执行和总结 年目标： 英语一年达到雅思水平，目标7.5分，可以进行基本交流以及文献阅读（最后附雅思考试日历） 阅读50本以上图书 中英文打字速度和打字准确率需要提高（最后附打字提升网站） 趁学生时代时间多，着力学习计算机基础（计算机网络，操作系统，计算机组成原理，c，c++，java，python） 数学基础学习：线性代数，微积分，概率论，离散数学 数学建模及matlab 蓝桥杯python算法比赛 健身，矫正驼背和颈椎 月目标：一月： 读四本书，编写至少两篇读书笔记 《the secret》、《小狗钱钱》 《穷爸爸，富爸爸》、《财富自由之路》 小猪佩奇，第一季，前二十集完成对英语听的训练 计划共花费二十二小时练习打字，共二十二天 学完线性代数 学完数据结构，学透学精 尝试完成智能优化算法的九分之四 坚持一周五次运动，争取每天跟着周六野老师做颈椎恢复 二月： 读四本书，编写至少两篇读书笔记 小猪佩奇，第一季，剩余二十五集完成对英语听的训练 计划共花费二十八小时练习打字，共二十八天 尝试完成智能优化算法的九分之五 学完微积分 学完计算机基础及组成原理，学透学精 坚持一周五次运动，争取每天跟着周六野老师做颈椎恢复 三月： 读四本书，编写至少两篇读书笔记 小猪佩奇，第一季剩余七集，第二季剩余二十集完成对英语听的训练 听单词，看单词，这个计划在二月底待定 学完概率论 坚持一周五次运动，争取每天跟着周六野老师做颈椎恢复 四月： 读四本书，编写至少两篇读书笔记 小猪佩奇，第二季，剩余二十六集完成对英语听的训练 学完离散数学 坚持一周五次运动，争取每天跟着周六野老师做颈椎恢复 五月： 读四本书，编写至少两篇读书笔记 小猪佩奇，第二季剩余七集，第三季剩余二十集完成英语听的训练 坚持一周五次运动，争取每天跟着周六野老师做颈椎恢复 六月： 读四本书，编写至少两篇读书笔记 小猪佩奇，第三季，剩余二十六集完成对英语听的训练 坚持一周五次运动，跟着周六野老师做颈椎恢复 七月： 读四本书，编写至少两篇读书笔记 小猪佩奇，第三季剩余六集，第四季剩余二十一集完成对英语听的训练 坚持一周五次运动，跟着周六野老师做颈椎恢复 八月： 读四本书，编写至少两篇读书笔记 小猪佩奇，第四季，剩余三十一集完成对英语听的训练 坚持一周五次运动，跟着周六野老师做颈椎恢复 九月： 读四本书，编写至少两篇读书笔记 坚持一周五次运动，跟着周六野老师做颈椎恢复 十月： 读四本书，编写至少两篇读书笔记 坚持一周五次运动，跟着周六野老师做颈椎恢复 十一月： 读四本书，编写至少两篇读书笔记 坚持一周五次运动，跟着周六野老师做颈椎恢复 十二月： 读四本书，编写至少两篇读书笔记 坚持一周五次运动，跟着周六野老师做颈椎恢复 附件打字网站：www.typingclub.com雅思考试日历：","link":"/2020/12/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/"},{"title":"如何迅速成为某一领域的高手","text":"比较优势是普通人逆袭的捷径 如何成为某一领域的高手呢，最简单有效的办法就是向某一领域中的高手学习，因为自学就像爬楼梯，跟着老师学就像坐飞机，有了老师的引导，学习效率就会事半功倍。 可是问题来了，高手为什么会愿意教你呢？这时候我们就要需要用到比较优势了。 比较优势是经济学名词，了解比较优势之前我们先要了解一下什么是机会成本，机会成本是指我们做一个选择后所丧失的不做该选择而可能获得的最大利益。简单的讲就是鱼和熊掌不可兼得的道理，我们如果选择上大学，我们就放弃了去搬砖赚钱的机会，这就是机会成本。比较优势就是指一个生产者低于另一个生产者的机会成本生产某有一种物品的行为。 由于有机会成本的存在，所以没有任何一个人在需要解决的所有事情上都具有比较优势，领域中的高手也一样，有很多事情在他们看起来低效简单，他们也就不愿意花费时间精力来处理这些事情，这时他就会选择外包这些事情，将自己的精力和时间投入到更高效的生产中。我们就可以利用我们自身的比较优势，选择帮助高手处理这些不需要太多能力就可以解决的事情，我们为高手提供价值。高手为我们提供机会接近他，观察他，我们进而反思自己和高手的差距，慢慢的日积月累，你也会成为领域中的高手。 国内有一家小有名气的影视工作室，工作室的创始人在读大学期间，利用自身的比较优势，主动为当时一家成绩显著的影视工作室做免费劳动力，他每周利用两天时间去那家工作室免费实习，他不断地学习，反思与高手的差距，慢慢经过时间的沉淀，他现在也拥有了一家小有名气的影视工作室。 最后还要说一点，比较优势虽然是普通人逆袭的捷径，但是过程一点也不容易，需要很明确的目标和很坚韧的心理素质。","link":"/2020/12/26/%E5%A6%82%E4%BD%95%E8%BF%85%E9%80%9F%E6%88%90%E4%B8%BA%E6%9F%90%E4%B8%80%E9%A2%86%E5%9F%9F%E7%9A%84%E9%AB%98%E6%89%8B/"},{"title":"【计算机学习】《大话数据结构》学习笔记","text":"笔者目前是一名自动化专业的本科生，开设自学计算机这个系列完全是因为兴趣使然，我会在这个系列里面更新我在自学计算机路上的点点滴滴以及我走过的坑，欢迎各位朋友添加我的个人微信一起交流学习。 本书采用的高级语言为c语言，除了用c语言实现书中内容，还可尝试用python来实现书中内容 第一遍学习，从头到尾全部学完，重复学习，建立知识体系 学习时，摘抄是非常好的习惯 学习每一章时，一定要将代码在电脑上运行一遍 学习完每一章，都要配合适当练习 学习数据结构不要只认准一本书，多看一些优秀书目 在开发中尝试使用数据结构 第1章 数据结构绪论对于学习，我们要有求甚解的精神。现在好多的算法都有对应函数完美的实现，但是我们还要继续弄懂算法的原理，因为我们只有模仿才能创新。如果只会开车，不懂汽车的结构，就永远造不出汽车。算法和数据结构的学习更是如此。 基本概念和术语数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。 可以输入到计算机中 能被计算机程序处理 数据元素：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。 数据项：一个数据元素可以由若干个数据项组成。 数据项是数据不可分割的最小项 数据对象：是性质相同的数据元素的集合，是数据的子集。 数据结构：是相互之间讯在一种或多种特定关系的数据元素的集合 逻辑结构 集合结构：集合结构中的数据元素除了同属于一个集合外，他们之间没有其他关系。 线性结构：线性结构中的数据元素之间是一对一的关系。 树形结构：树形结构中的数据元素之间存在一种一对多的层次关系。 图形结构：图形结构的数据元素是多对多的关系。 物理结构物理结构也叫存储结构，顾名思义是数据的逻辑结构在计算机内存中的排列方式 顺序存储结构：是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系一样。 链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。 逻辑结构面向问题，而物理结构面向的是计算机，其基本目的就是将数据及其逻辑结构存储在计算机内存中 抽象数据类型数据类型：是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。 例如：整形、实形、数组 抽象是指抽出事物具有的普遍性的本质。抽象是一种思考问题的方式，他隐藏了繁杂的细节，只保留实现目标所必需的信息。 抽象数据类型：是指一个数据模型及定义在该模型上的一组操作。 对数据概念可以这样总结。现在有一份文档，里面记录了社区全部居民的核酸检测报告，这份文档报告就是数据，里面的社区全部居民核酸检测报告就是数据对象，每一位居民的核酸检测报告就是数据元素，检测报告中又包括姓名，年龄，身份证号，检测结果等信息，这些个人信息就是数据项。 抽象数据类型就像是Java或者python中的类以及c语言中的结构体。 第2章 算法","link":"/2021/01/13/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0%E3%80%91%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"【金融理财】之《小狗钱钱》","text":"","link":"/2021/01/12/%E3%80%90%E9%87%91%E8%9E%8D%E7%90%86%E8%B4%A2%E3%80%91%E4%B9%8B%E3%80%8A%E5%B0%8F%E7%8B%97%E9%92%B1%E9%92%B1%E3%80%8B/"}],"tags":[{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"机器学习","slug":"机器学习","link":"/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"进化算法","slug":"进化算法","link":"/tags/%E8%BF%9B%E5%8C%96%E7%AE%97%E6%B3%95/"},{"name":"遗传算法","slug":"遗传算法","link":"/tags/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"博客更改","slug":"博客更改","link":"/tags/%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%94%B9/"},{"name":"提高效率","slug":"提高效率","link":"/tags/%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87/"},{"name":"杂谈","slug":"杂谈","link":"/tags/%E6%9D%82%E8%B0%88/"},{"name":"其他","slug":"其他","link":"/tags/%E5%85%B6%E4%BB%96/"},{"name":"计算机学习","slug":"计算机学习","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/"},{"name":"金融理财","slug":"金融理财","link":"/tags/%E9%87%91%E8%9E%8D%E7%90%86%E8%B4%A2/"}],"categories":[{"name":"其他","slug":"其他","link":"/categories/%E5%85%B6%E4%BB%96/"},{"name":"博客相关","slug":"其他/博客相关","link":"/categories/%E5%85%B6%E4%BB%96/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"},{"name":"机器学习","slug":"机器学习","link":"/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"进化算法","slug":"机器学习/进化算法","link":"/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E8%BF%9B%E5%8C%96%E7%AE%97%E6%B3%95/"},{"name":"效率教程","slug":"效率教程","link":"/categories/%E6%95%88%E7%8E%87%E6%95%99%E7%A8%8B/"},{"name":"个人杂谈","slug":"其他/个人杂谈","link":"/categories/%E5%85%B6%E4%BB%96/%E4%B8%AA%E4%BA%BA%E6%9D%82%E8%B0%88/"},{"name":"学习相关","slug":"其他/学习相关","link":"/categories/%E5%85%B6%E4%BB%96/%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3/"},{"name":"书影音笔记","slug":"书影音笔记","link":"/categories/%E4%B9%A6%E5%BD%B1%E9%9F%B3%E7%AC%94%E8%AE%B0/"}]}